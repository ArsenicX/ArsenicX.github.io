<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Android开发者指南 - 学习笔记 | ArsenicX</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://ArsenicX.github.io//favicon.ico?v=1587889481543">
<link rel="stylesheet" href="https://ArsenicX.github.io//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="官网地址
第一部分 App Basics：
入门


在Design标签下，点击Button图标，会出现一个Edit Baseline


Intent：intent.putExtra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在..." />
    <meta name="keywords" content="Android" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://ArsenicX.github.io/">
        <img src="https://ArsenicX.github.io//images/avatar.png?v=1587889481543" class="site-logo">
        <h1 class="site-title">ArsenicX</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/java" class="site-nav">
            Java
          </a>
        
      
        
          <a href="/git" class="site-nav">
            Git
          </a>
        
      
        
          <a href="/android" class="site-nav">
            Android
          </a>
        
      
        
          <a href="/others" class="site-nav">
            Others
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      
    </div>
    <div class="site-footer">
      <a href="https://github.com/ArsenicX" target="_blank">Github</a> | <a class="rss" href="https://ArsenicX.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Android开发者指南 - 学习笔记</h2>
            <div class="post-date">2020-03-25</div>
            
            <div class="post-content" v-pre>
              <h1 id="官网地址"><a href="https://developer.android.google.cn/guide">官网地址</a></h1>
<h1 id="第一部分-app-basics">第一部分 App Basics：</h1>
<h1 id="入门">入门</h1>
<ul>
<li>
<p>在Design标签下，点击Button图标，会出现一个Edit Baseline<img src="https://ArsenicX.github.io//post-images/1585280651360.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>Intent</strong>：intent.putExtra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在您的应用与其他应用交互时这些键始终保持唯一</p>
<pre><code class="language-java">public static final String EXTRA_MESSAGE = &quot;com.example.myfirstapp.MESSAGE&quot;;
intent.putExtra(EXTRA_MESSAGE, message);
</code></pre>
</li>
<li>
<p><strong><a href="https://developer.android.google.cn/guide/components/fundamentals">应用可以通过一些途径与其他应用共享数据以及访问系统服务</a></strong></p>
<ol>
<li>可以安排两个应用共享同一 Linux 用户 ID，在这种情况下，它们能够相互访问彼此的文件。 为了节省系统资源，可以安排具有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM（应用还必须使用相同的证书签署）</li>
</ol>
</li>
</ul>
<h1 id="资源文件-resources">资源文件 Resources</h1>
<h2 id="res资源目录及限定符"><code>res/</code>资源目录及限定符</h2>
<h3 id="res目录内支持的资源目录"><code>res/</code>目录内支持的资源目录</h3>
<table>
<thead>
<tr>
<th>目录</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>animator/</td>
<td>用于定义<a href="https://developer.android.google.cn/guide/topics/graphics/prop-animation.html">属性动画</a>的 XML 文件。</td>
</tr>
<tr>
<td>anim/</td>
<td>定义<a href="https://developer.android.google.cn/guide/topics/graphics/view-animation.html#tween-animation">渐变动画</a>的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 <code>animator/</code> 目录。）</td>
</tr>
<tr>
<td>color/</td>
<td>用于定义颜色状态列表的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/color-list-resource.html">颜色状态列表资源</a></td>
</tr>
<tr>
<td>drawable/</td>
<td>位图文件（<code>.png</code>、<code>.9.png</code>、<code>.jpg</code>、<code>.gif</code>）或编译为以下可绘制对象资源子类型的 XML 文件：<br> 1.  位图文件<br> 2.  九宫格（可调整大小的位图）<br> 3.  状态列表<br> 4.  形状<br> 5.  动画可绘制对象<br> 6.  其他可绘制对象<br>  <br>请参阅 <a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource.html">可绘制对象资源</a>。</td>
</tr>
<tr>
<td>mipmap/</td>
<td>适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 <code>mipmap/</code> 文件夹管理启动器图标的详细信息，请参阅<a href="https://developer.android.google.cn/tools/projects/index.html#mipmap">管理项目概览</a>。</td>
</tr>
<tr>
<td>layout/</td>
<td>用于定义用户界面布局的 XML 文件。 请参阅<a href="https://developer.android.google.cn/guide/topics/resources/layout-resource.html">布局资源</a>。</td>
</tr>
<tr>
<td>menu/</td>
<td>用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/menu-resource.html">菜单资源</a>。</td>
</tr>
<tr>
<td>raw/</td>
<td>要以原始形式保存的任意文件。要使用原始 <code>InputStream</code> 打开这些资源，请使用资源 ID（即 <code>R.raw.filename</code>）调用 <code>Resources.openRawResource()</code>。<br>但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 <code>assets/</code> 目录下（而不是 <code>res/raw/</code>）。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 <code>AssetManager</code> 读取这些文件。</td>
</tr>
<tr>
<td>values/</td>
<td>包含字符串、整型数和颜色等简单值的 XML 文件。<br><br/>其他 <code>res/</code> 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均定义一个资源。例如，<code>&lt;string&gt;</code> 元素创建 <code>R.string</code> 资源，<code>&lt;color&gt;</code> 元素创建 <code>R.color</code> 资源。<br><br>由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：<br> 1.  arrays.xml，用于资源数组（<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#TypedArray">类型化数组</a>）。<br> 2.  colors.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Color">颜色值</a>。<br> 3.  dimens.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Dimension">尺寸值</a>。<br> 4.  strings.xml：<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html">字符串值</a>。<br> 5.  styles.xml：<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html">样式</a><br>请参阅<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html">字符串资源</a>、<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html">样式资源</a>和<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html">更多资源类型</a>。</td>
</tr>
<tr>
<td>xml/</td>
<td>可以在运行时通过调用 <code>Resources.getXML()</code> 读取的任意 XML 文件。各种 XML 配置文件（如<a href="https://developer.android.google.cn/guide/topics/search/searchable-config.html">可搜索配置</a>）都必须保存在此处。</td>
</tr>
</tbody>
</table>
<h3 id="资源限定符"><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#table2">资源限定符</a></h3>
<table>
<thead>
<tr>
<th>配置</th>
<th>限定符值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>语言和区域</td>
<td>示例：<br/><code>en</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>fr</code><br>
<code>en-rUS</code><br>
<code>fr-rFR</code><br>
<code>fr-rCA</code><br>
等等    | 语言通过由两个字母组成的 <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO 639-1</a> 语言代码定义，可以选择后跟两个字母组成的 <a href="https://www.iso.org/obp/ui/#iso:pub:PUB500001:en">ISO 3166-1-alpha-2</a> 区域码（前带小写字母“<code>r</code>”）。 |<br>
| smallestWidth | sw<N>dp<br>示例：<br><code>sw320dp</code> <code>sw600dp</code> <code>sw720dp</code> | 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 <code>&lt;N&gt;</code>dp。 |<br>
| 屏幕尺寸      | small<code></code>normal<code></code>large<code></code>xlarge                    | <code>small</code>：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。<br/> <code>normal</code>：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。 <br/><code>large</code>：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。<br/> <code>xlarge</code>：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。<em>API 级别 9 中的新增配置。</em> |<br>
| ...           | ...                                                | ...                                                          |<br>
<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#BestMatch"><strong>系统对于不同资源限定符的选择算法</strong></a><br> 1. 淘汰掉和设备冲突的资源文件。比如设备如果是英文<code>en</code>的，就会先直接排除掉<code>fr</code>、<code>cn</code>等限定符的资源<br> 2. 依照<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#table2">此表</a><strong>从上到下</strong>寻找有没有匹配的。即先找有没有<em>移动国家代码 <code>MCC/MNC</code></em> 限定的资源，有的话直接排除其他；反之寻找有没有<em>语言和区域</em> 限定的资源。<br> 3. 重复第2步，从二级目录开始依次淘汰，只到剩下只有一个资源目录。比如现在已经通过<em>语言和区域</em> 排除过后依旧剩下了3个资源目录，则再看语言限定符之后，有无<em>布局方向</em> 限定符，有的话排除其他；反之寻找有没有<em>屏幕基本尺寸 <code>smallestWidth</code></em>，只到剩下最后一个资源文件夹。<br><br>	<strong>注意⚠️：<em>屏幕像素密度 <code>dpi</code></em> 为特例，不能淘汰</strong> <br>		如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html">支持多种屏幕</a>。<br>		根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统<strong>不会</strong>使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。<br><br>举个栗子🌰：</p>
<blockquote>
<p>假设目前有以下资源目录：</p>
<pre><code>drawable/
drawable-en/
drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</code></pre>
<p>且设备的配置如下：</p>
<p>​	语言区域 = <code>en-GB</code><br>
​	屏幕方向 = <code>port</code><br>
​	屏幕像素密度 = <code>hdpi</code><br>
​	触摸屏类型 = <code>notouch</code><br>
​	主要文本输入法 = <code>12key</code></p>
<p><br>首先，可以排除<code>drawable-fr-rCA/</code> 因为和设备配置冲突</p>
<pre><code class="language-java">drawable/
drawable-en/
// drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</code></pre>
<p>其次，因为目前目录中有语言限定符，且符合设备，所以可以继续排除非<code>en</code>开头的限定符</p>
<pre><code class="language-java">// drawable/
drawable-en/
drawable-en-port/
drawable-en-notouch-12key/
// drawable-port-ldpi/
// drawable-port-notouch-12key/
</code></pre>
<p>筛选过后还剩下不止一个资源，所以重复第二步方法筛选。因为<code>port</code>优先级比<code>notouch</code>高，所以排除<code>notouch</code></p>
<pre><code class="language-java">// drawable-en/
drawable-en-port/
// drawable-en-notouch-12key/
</code></pre>
<p>最后得到唯一的资源目录。之后在程序请求资源时都将会在该目录下找</p>
</blockquote>
<h2 id="运行时变更配置如何处理">运行时变更配置如何处理</h2>
<p>A. 在配置变更期间保留对象：<br>	通常我们可以依靠系统通过<code>onSaveInstanceState()</code> 回调保存的 <code>Bundle</code>， 但是它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。所以当重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作时，此时建议通过保留<code>Fragment</code>来减轻重新初始化 Activity 的负担，可以在 <code>Fragment</code>中包含要保留的有状态对象的<strong>引用</strong>。<br><br>要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：</p>
<p>​	1. 扩展 <code>Fragment</code> 类并声明对有状态对象的引用。</p>
<p>​	2. 在创建片段后调用 <code>setRetainInstance(boolean)</code>。</p>
<p>​	3. 将片段添加到 Activity。</p>
<p>​	4. 重启 Activity 后，使用 <code>FragmentManager</code> 检索片段。<br>例如：</p>
<pre><code class="language-java">public class RetainedFragment extends Fragment {

    // data object we want to retain
    private MyDataObject data;

    // this method is only called once for this fragment
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // retain this fragment
        setRetainInstance(true);
    }

    public void setData(MyDataObject data) {
        this.data = data;
    }

    public MyDataObject getData() {
        return data;
    }
}
</code></pre>
<blockquote>
<p>**注意⚠️：**尽管可以存储任何对象，但是切勿传递与 <code>Activity</code> 绑定的对象，例如，<code>Drawable</code>、<code>Adapter</code>、<code>View</code> 或其他任何与 <code>Context</code> 关联的对象。以免内存泄漏。</p>
</blockquote>
<p>然后，使用 <code>FragmentManager</code> 将片段添加到<code>Activity</code>。在运行时配置变更期间再次启动<code>Activity</code>时，您可以获得片段中的数据对象。 例如，按如下方式定义<code>Activity</code>：</p>
<pre><code class="language-java">public class MyActivity extends Activity {

    private RetainedFragment retainedFragment;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // find the retained fragment on activity restarts
        FragmentManager fm = getFragmentManager();
        retainedFragment = (RetainedFragment) fm.findFragmentByTag(“data”);

        // create the fragment and data the first time
        if (retainedFragment == null) {
            // add the fragment
            retainedFragment = new RetainedFragment();
            fm.beginTransaction().add(retainedFragment, “data”).commit();
            // load the data from the web
            retainedFragment.setData(loadMyData());
        }

        // the data is available in retainedFragment.getData()
        ...
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // store the data in the fragment
        retainedFragment.setData(collectMyLoadedData());
    }

</code></pre>
<p>在此示例中，<code>onCreate()</code> 添加了一个片段或恢复了对它的引用。此外，<code>onCreate()</code> 还将有状态的对象存储在片段实例内部。<code>onDestroy()</code> 对所保留的片段实例内的有状态对象进行更新。</p>
<p><br><br>B. 自行处理配置变更：<br>	如果应用在配置改变时无需更新资源，并且如果因性能限制需要尽量避免重启，则可声明 <code>Activity</code> 将自行处理配置变更，这样可以阻止系统重启 <code>Activity</code>。<br></p>
<blockquote>
<p>​	自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在您<strong>必须</strong>避免 Activity 因配置变更而重启这一<strong>万般无奈</strong>的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并<strong>不建议</strong>使用此方法。</p>
</blockquote>
<p>如果要声明由 <code>Activity</code> 处理配置变更，在清单文件中添加<code>android:configChanges</code>元素即可。在其<a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config">属性文档</a>中列出了可以添加的属性值。</p>
<pre><code class="language-html">&lt;activity android:name=&quot;.MyActivity&quot;
          android:configChanges=&quot;orientation|keyboardHidden&quot;
          android:label=&quot;@string/app_name&quot;&gt;
</code></pre>
<p>现在，当其中一个配置发生变化时，<code>MyActivity</code> 便不会重启。相反，<code>MyActivity</code> 会收到对 <code>onConfigurationChanged()</code> 的调用。向此方法传递 <code>Configuration</code> 对象指定新设备配置。您可以通过读取<code>Configuration</code> 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的<code>Resources</code> 对象会相应地进行更新，以根据新配置返回资源，这样，您就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。</p>
<blockquote>
<p><strong>注意：<strong>从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，</strong>“屏幕尺寸”也会发生变化</strong>。因此，在开发针对 API 级别 13 或更高版本（正如 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min"><code>minSdkVersion</code></a> 和 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target"><code>targetSdkVersion</code></a> 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 <code>&quot;orientation&quot;</code> 值以外，您还必须添加 <code>&quot;screenSize&quot;</code> 值。</p>
</blockquote>
<p>例如，以下 <code>onConfigurationChanged()</code> 实现检查当前设备方向：</p>
<pre><code class="language-java">@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    // Checks the orientation of the screen
    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show();
    } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){
        Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre>
<blockquote>
<p>​	在声明由 Activity 处理配置变更时，您有责任重置要为其提供备用资源的所有元素。 如果您声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 <code>onConfigurationChanged()</code> 期间将每个资源重新分配给每个元素。</p>
<p>​	如果无需基于这些配置变更更新应用，则可不用实现 <code>onConfigurationChanged()</code>。在这种情况下，仍将使用在配置变更之前用到的所有资源。</p>
</blockquote>
<p>如需了解有关可以在 Activity 中处理哪些配置变更的详细信息，请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config"><code>android:configChanges</code></a> 文档和 <a href="https://developer.android.google.cn/reference/android/content/res/Configuration.html"><code>Configuration</code></a>类。</p>
<h2 id="本地化-eng"><a href="https://developer.android.google.cn/guide/topics/resources/localization">本地化 Eng</a></h2>
<h2 id="复合xml-资源-eng"><a href="https://developer.android.google.cn/guide/topics/resources/complex-xml-resources">复合XML 资源 Eng</a></h2>
<h2 id="资源类型详解-eng"><a href="https://developer.android.google.cn/guide/topics/resources/available-resources">资源类型详解 Eng</a></h2>
<h1 id="应用清单-manifest">应用清单 manifest</h1>
<h2 id="应用清单">应用清单</h2>
<p>​	<code>android:label</code>用来指定<code>app</code>名称或<code>activity</code>名称。因为<code>activity</code>比<code>application</code>更具体，所以会优先使用<code>activity</code>中的<code>android:label</code>。</p>
<h2 id="清单文件结构及详解"><a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro#filestruct">清单文件结构及详解</a></h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;manifest&gt;

    &lt;uses-permission /&gt;
    &lt;permission /&gt;
    &lt;permission-tree /&gt;
    &lt;permission-group /&gt;
    &lt;instrumentation /&gt;
    &lt;uses-sdk /&gt;
    &lt;uses-configuration /&gt;  
    &lt;uses-feature /&gt;  
    &lt;supports-screens /&gt;  
    &lt;compatible-screens /&gt;  
    &lt;supports-gl-texture /&gt;  

    &lt;application&gt;

        &lt;activity&gt;
            &lt;intent-filter&gt;
                &lt;action /&gt;
                &lt;category /&gt;
                &lt;data /&gt;
            &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/activity&gt;

        &lt;activity-alias&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/activity-alias&gt;

        &lt;service&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data/&gt;
        &lt;/service&gt;

        &lt;receiver&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/receiver&gt;

        &lt;provider&gt;
            &lt;grant-uri-permission /&gt;
            &lt;meta-data /&gt;
            &lt;path-permission /&gt;
        &lt;/provider&gt;

        &lt;uses-library /&gt;

    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
<h2 id="文件约定规则">文件约定规则</h2>
<ul>
<li>元素：
<ul>
<li>只有 <code>&lt;manifest&gt;</code> 和 <code>&lt;application&gt;</code> 元素是必需的，它们都必须存在并且只能出现一次。</li>
<li>同一级别的元素通常不分先后顺序。例如，<code>&lt;activity&gt;</code>、<code>&lt;provider&gt;</code> 和 <code>&lt;service&gt;</code> 元素可以按任何顺序混合在一起。但这条规则有两个主要例外：
<ul>
<li><code>&lt;activity-alias&gt;</code> 元素必须跟在别名所指的 <code>&lt;activity&gt;</code> 之后。</li>
<li><code>&lt;application&gt;</code> 元素必须是 <code>&lt;manifest&gt;</code> 元素内最后一个元素。换言之，<code>&lt;/manifest&gt;</code> 结束标记必须紧接在 <code>&lt;/application&gt;</code> 结束标记后。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="权限-permission"><a href="https://developer.android.google.cn/guide/topics/permissions/overview">权限 Permission</a></h1>
<h2 id="概述-eng">概述 Eng</h2>
<ul>
<li>
<p>对于硬件设备的需求的权限声明</p>
<p>​	在调用设备硬件（比如蓝牙或相机）时，需要用户的授权才能使用。但是，并不是所有的设备都有这些硬件，所以别忘了在用户清单中添加<code>&lt;uses-feature&gt;</code>（<code>&lt;uses-feature&gt;</code>说明可见「设备 Device - 应用兼容性概述 Device compatibility overview - 设备特征（Feature ID）」）<br>	如果你声明了<code>android:required=&quot;false&quot;</code>，则 Google Play 会允许没有该硬件的设备安装。而你要在运行时使用 <code>PackageManager.hasSystemFeature()</code>检测设备是否具有某项硬件，如果没有，记得停用使用该硬件的功能。</p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#permission_enforcement">权限的其他功用 Eng</a></p>
<p>​	权限并不只是为了去调用设备的功能，我们也可以自定义权限来自定义限制。</p>
<ol>
<li>Activity 权限限制</li>
</ol>
<p>​	 在<code>&lt;activity&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以跳转该 Activity。<br>	这个权限会在``Context.startActivity()<code>和</code>Activity.startActivityForResult()<code>期间检查，若没有权限的话则调用者会抛出</code>SecurityException`异常。</p>
<ol start="2">
<li>Service 权限限制</li>
</ol>
<p>​	在<code>&lt;service&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以启用或绑定该 Service。<br>	这个权限会在<code>Context.startService()</code>，<code>Context.stopService()</code>和<code>Context.bindService()</code>过程中检查，若没有权限的话则调用者会抛出<code>SecurityException</code>异常。</p>
<ol start="3">
<li>Broadcast 权限限制</li>
</ol>
<p>​	在<code>&lt;receiver&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以向已连接的 BroadcastReceiver发送广播。<br>	因为系统会尝试将广播传递给给定的接受者，所以这个权限会在<code>Context.sendBroadcast()</code>返回后检查；同理，若没有权限的话也不会抛出异常，他只是没有传递出去那个 Intent。</p>
<p>​	同样，也可以给<code>Context.registerReceiver()</code>提供权限去控制 <a href="https://developer.android.google.cn/guide/topics/permissions/overview#broadcast_permission_enforcement">who can broadcast to a programmatically registered receiver. </a>。这种情况下，权限会在调用<code>Context.sendBroadcast()</code>时检查，以去限制哪种广播接收器被允许去接受广播。</p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#auto-adjustments">自动修正权限 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#normal-dangerous">保护等级 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#normal-dangerous">权限组 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#viewing">查看应用涉及到的权限 Eng</a></p>
</li>
</ul>
<h2 id="使用权限的最佳做法">使用权限的最佳做法</h2>
<h3 id="避免请求不必要的权限">避免请求不必要的权限</h3>
<p>本部分提供了常见的替代方法：</p>
<ol>
<li>改用 Intent<br>	要让应用执行某项任务，有两种方法可以选择。应用可以要求提供权限来自行执行该任务，也可以使用 intent 让其他应用执行该任务。<br>	例如，当我们需要使用摄像头拍照时，可以请求<code>CAMERA</code>权限以便应用直接访问摄像头，也可以使用 Intent 来调用其他支持拍照的应用，这样的话就无需请求<code>CAMERA</code>权限了。比如可以使用 Intent 操作类型 <code>MediaStore.ACTION_IMAGE_CAPTURE</code> 或 <code>MediaStore.ACTION_VIDEO_CAPTURE</code> 来拍摄图像或视频。</li>
</ol>
<pre><code>​	&lt;br&gt;如果使用权限：

- 当您执行操作时，您的应用可以完全控制用户体验。不过，这样需要自行创建对应的界面，会增加代码的复杂性。
- 系统会在运行时或安装时（具体取决于用户的 Android 版本）提示用户授予权限一次。如果用户未授予权限（或之后撤消权限），则应用将根本无法执行操作。

如果使用 intent：

- 您不必为操作设计界面。利用 Intent 而调用的应用将提供界面。
- 用户可以使用他们首选的应用执行任务。例如，用户可以选择用他们喜爱的照片应用拍照。
- 如果用户没有适用于操作的默认应用，则系统会提示用户选择一款应用。如果用户未指定默认处理程序，则他们每次执行此操作时都可能必须处理一个额外的对话框。
</code></pre>
<ol start="2">
<li>
<p>不要让用户感到无所适从</p>
<p>​	如果用户运行的是 Android 6.0（API 级别 23）或更高版本，则用户必须在运行应用时为其授予权限。如果您让用户一次面对大量的权限请求，可能会让用户感到无所适从。<br>	合理的做法是，在用户第一次打开应用时就立即请求所有<strong>必要</strong>的权限。比如您的应用是摄影应用，那在用户首次打开应用的时候被要求授权摄像头权限的时候，用户就不会感到不妥；但是，如果同一应用还具有与联系人分享照片的功能，那就建议不要在首次启动时请求授权<code>READ_CONTACT</code>权限，而是应该在用户进行「分享」操作时再请求。<br>	当然，如果应用提供教程，也可以在教程过后请求提供权限。</p>
</li>
<li>
<p>失去音频焦点后暂停媒体</p>
<p>​	有这样一种使用场景，当用户接电话时，应用需要转入后台并且将其媒体播放器暂停或静音。通常的做法是使用 <code>PhoneStateListener</code> 或监听 <code>android.intent.action.PHONE_STATE</code> 的广播，以监听通话状态有无变化。<br>	可是这种解决方法需要请求 <code>READ_PHONE_STATE</code> 权限，而这个权限将会同时得到用户广泛的敏感数据（比如用户的设备和 SIM 硬件 ID 以及来电的电话号码）</p>
<p>​	这时就可以用另一种方式来解决。您可以通过为应用请求 <code>AudioFocus</code>，在没有 <code>READ_PHONE_STATE</code> 或 <code>MODIFY_PHONE_STATE</code> 权限的情况下检测用户是否在通话中。只需将对音频放入后台所需的代码放入<code>onAudioFocusChange()</code> 事件处理程序，当操作系统转换其音频焦点时，它将自动运行。要详细了解如何执行此操作，请参阅<a href="https://developer.android.google.cn/training/managing-audio/audio-focus.html">此文档</a></p>
</li>
<li>
<p>确定正在运行实例的设备</p>
<p>​	在这种情况下，您需要一个唯一标识符来确定您的应用实例正在哪个设备上运行。<br>	应用可能具有设备特定的偏好设置或消息（例如，在云端为用户保存设备特定的播放列表，以便他们在车上和家里可以有不同的播放列表）。常见的解决方案是利用设备标识符（如 <code>Device IMEI</code>），但这需要 <code>Device ID and call information</code> 权限组（M+ 中为 <code>PHONE</code>）。它还使用一个无法重置且在所有应用之间共享的标识符。<br>	下面两种方法可以替代这些类型的标识符：</p>
<ol>
<li>使用 <code>com.google.android.gms.iid</code> InstanceID API。<code>getInstance(Context context).getID()</code> 将为您的应用实例返回一个唯一设备标识符。结果是一个应用实例作用域标识符，在存储有关应用的信息时，该标识符可用作键，如果用户重新安装应用，该标识符会重置。</li>
<li>使用 <a href="https://developer.android.google.cn/reference/java/util/UUID.html#randomUUID()"><code>randomUUID()</code></a> 之类的基本系统函数创建您自己的标识符，其作用域限定为应用的存</li>
</ol>
</li>
<li>
<p>为广告或用户分析创建唯一标识符</p>
<p>​	在这种情况下，您需要一个唯一标识符来为没有登录您应用的用户构建配置文件（例如，用于广告定位或衡量转化率）。<br>	为广告和用户分析构建配置文件有时需要一个在其他应用之间共享的标识符。此问题的常见解决方案需要利用设备标识符（如 <code>Device IMEI</code>），这需要 <code>Device ID</code> <code>and call information</code> 权限组（API 级别 23+ 中为 <code>PHONE</code>），并且无法由用户重置。无论是上述哪种情况，除了使用不可重置的标识符并请求用户可能认为不寻常的权限外，还会违反 <a href="https://play.google.com/about/developer-content-policy.html">Play 开发者计划政策</a>。<br>	遗憾的是，在这些情况下，使用 <code>com.google.android.gms.iid</code> InstanceID API 或系统函数创建应用作用域 ID 并不是适当的解决方案，因为可能需要在应用之间共享该 ID。一种替代解决方案是使用通过 <code>getId()</code> 方法从<code>AdvertisingIdClient.Info</code> 类中获取的 <code>Advertising Identifier</code>。您可以使用 <code>getAdvertisingIdInfo(Context)</code> 方法创建一个 <code>AdvertisingIdClient.Info</code> 对象，并调用 <code>getId()</code> 方法来使用该标识符。<em><strong>请注意，此方法会产生阻塞</strong></em>，因此，您不应从主线程调用它；有关此方法的详细说明，请点击<a href="https://developer.android.google.cn/google/play-services/id.html">此处</a>。</p>
</li>
</ol>
<h2 id="自定义权限-eng"><a href="https://developer.android.google.cn/guide/topics/permissions/defining">自定义权限 Eng</a></h2>
<h1 id="第二部分-设备-device">第二部分 设备 Device</h1>
<h1 id="应用兼容性-device-compatibility">应用兼容性 Device compatibility</h1>
<h2 id="概述">概述</h2>
<h3 id="设备特征feature-id">设备特征（Feature ID）</h3>
<p>​	为了使你的应用在用户设备上可以正常使用，<code>Android</code>为硬件和软件设置了<code>特征ID</code>。硬件比如加速器传感器，它的特征ID是<code>FEATURE_SENSOR_COMPASS</code>；软件比如小部件widget，他的特征ID是 <code>FEATURE_APP_WIDGETS</code></p>
<p>​	假如你的应用是基于某项特征运作的，并且你不希望没有该特征的设备安装你的应用，你就可以在清单文件中使用<code>&lt;user-feature&gt;</code>来作出限制。</p>
<blockquote>
<p>例如，假设你的应用在没有加速度传感器的设备上会无法使用。这时你就可以在清单文件中加入</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.sensor.compass&quot;
                  android:required=&quot;true&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>
<p>这样，用户在持有没有加速度传感器的设备在Google Play Store下载该应用时就会被拒绝安装。</p>
<p>如果你的应用并不是一定需要该特征的话，你也可以把<code>android:required=&quot;true&quot;</code>的<code>true</code>改为<code>false</code>，然后在运行时判断设备是否具有该特征。如果没有的话再选择停用使用了该特征的功能。</p>
<pre><code class="language-java">PackageManager pm = getPackageManager();
//判断是否具有某特征ID
if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) {
    // This device does not have a compass, turn off the compass feature
    disableCompassFeature();
} 
</code></pre>
</blockquote>
<blockquote>
<p><strong>注意</strong>⚠️：某些系统的权限（<code>permission</code>）会隐式的检查设备是否具有特征（<code>feature ID</code>）。</p>
<p>比如，如果你的应用请求了蓝牙的使用权限：</p>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;
</code></pre>
<p>那Google Play Store就会自动隐式检测设备是否具有蓝牙硬件，若没有的话就会拒绝安装。</p>
<p>如果不想被隐式检查的话就需要手动设置</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.bluetooth&quot;
                  android:required=&quot;false&quot; /&gt;
    ...
&lt;/manifest&gt; 
</code></pre>
</blockquote>
<h3 id="平台版本-platform-version">平台版本 Platform version</h3>
<p>​	因为<code>Android</code>系统的向后兼容特性，我们需要在<a href="https://developer.android.google.cn/studio/build/index.html#build-files"><code>build.gradle</code></a>中设置<code>SdkVersion</code>以保证我们的应用可以正常工作。<br></p>
<pre><code class="language-java">android {
  defaultConfig {
    applicationId 'com.example.myapp'

    // 安装该应用的所需的最低版本API
    minSdkVersion 15

    // 在所有测试设备中，最高API设备的API
    targetSdkVersion 28

    ...
  }
}
</code></pre>
<p>​	<strong>注意⚠️</strong>：<br>	1. 如果<code>manifest</code>和<code>build.gradle</code>中同时设置了<code>minSdkVersion</code> and <code>targetSdkVersion</code>，则以<code>build.gradle</code>为准<br>	2.  <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target"><code>targetSdkVersion</code></a>并不会阻止高于它的设备安装该应用，但是需要注意的是，它决定了该应用是否继承新版本的更改。<br>	例如：</p>
<blockquote>
<p>在<code>Android4.4</code>更新中，为了省电，使用<code>AlarmManager API</code>创建的警报由之前的「准时提醒」改为了「批量同时提醒」</p>
<blockquote>
<p>二者区别：倘若创建了16:01:00和16:01:30两个时间的警报，旧版本会提醒两次，而新版本会合并为一次同时提醒2个事件。比之前减少一次唤醒，节省电量。</p>
</blockquote>
<p>倘若应用<code>targetSdkVersion</code>设置为最新版本，则在运行时警报提醒会变为「批量同时提醒」；而若是没有及时更新<code>targetSdkVersion</code>，则应用在运行时还是会「准时提醒」</p>
</blockquote>
<h2 id="不同屏幕尺寸兼容">不同屏幕尺寸兼容</h2>
<h3 id="使用最小宽度限定符">使用最小宽度限定符</h3>
<p><code>res/layout/main.xml</code>即代表默认布局，<code>res/layout-sw600dp/main.xml</code>即代表屏幕宽度大于等于 600dp 的设备所使用的布局。</p>
<h3 id="使用布局别名">使用布局别名</h3>
<p>​	因为最小宽度限定符只能使用在 Android3.2 以上的设备上面，所以当设备版本号低于 Android3.2 时，仍然会出现布局出错的问题，这是我们就需要专门为 Android3.2 以下的设备新建一个<code>res/layout-large</code>文件夹用来放置适配UI。<br>	可是为了适配 Android3.2 以下的设备专门新开一个文件夹，其中所有的资源都要从<code>res/layout-sw600dp/main.xml</code>复制一份，一方面浪费空间，另一番面后续维护容易遗漏。这时我们就可以使用布局别名。<br>	首先新建一个<code>res/layout/main_twopanes.xml</code>用来放置大尺寸屏幕下的布局和资源，然后修改<code>res/values-large/layout.xml</code>和``res/layout-sw600dp/main.xml`为下：</p>
<pre><code class="language-xml">&lt;resources&gt;
    &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;
&lt;/resources&gt;
</code></pre>
<h3 id="9-格式位图">. 9 格式位图</h3>
<p>​	支持不同尺寸的屏幕，意味着图像资源也需要能够适应不同的尺寸。而在图片的缩放上，经常会出现差强人意的效果，这时我们就可以使用 . 9格式的位图，来固定哪部分可以被缩放拉伸，而哪部分不可以。<br>	例如可用于对话消息框背景，能够在消息文本多少不确定的情况下保持眼睛不变形：<img src="https://upload-images.jianshu.io/upload_images/291600-66b458ac8f0909f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/901" alt="" loading="lazy"><br>	将图像格式改为 <code>.9.png</code>即可使图片成为 .9 格式并支持自定义拉伸位置。左边和上边区域定义可以拉伸的位置，而右边和下边定义图片中内容填充的位置。</p>
<h2 id="适配刘海屏-eng"><a href="https://developer.android.google.cn/guide/topics/display-cutout">适配刘海屏 Eng</a></h2>
<h2 id="声明受限屏幕的支持">声明受限屏幕的支持</h2>
<p>因为一些原因可能我们不想使一个apk同时支持所有屏幕比例的设备，这时我们可以作出一些限制。</p>
<ol>
<li>
<p><a href="https://developer.android.google.cn/training/multiple-apks/screensize.html">针对不同屏幕单独发布apk（依赖Google Play）</a></p>
</li>
<li>
<p>声明最大长宽比<br></p>
<p>​	可以设定一个最大长宽比，当应用在屏幕长宽比超过限定的设备上运行时，应用会做出适配。如果应用定位到 API 26 或更高版本会根据其布局填充屏幕；而 API 25 或更低版本会将应用界面大小限制为长宽比为 16:9 的窗口，手机屏幕将带有黑边运行应用。</p>
<p>​	要为 Android 8.0（API 级别 26）和更高版本设置最大长宽比，请在您的 <code>&lt;activity&gt;</code> 标记中使用 <code>android:MaxAspectRatio</code> 声明最大比例。</p>
<pre><code class="language-xml">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --&gt;
&lt;!-- Use a letterbox on screens larger than 2.4 --&gt;
&lt;activity android:maxAspectRatio=&quot;2.4&quot;&gt;
 ...
&lt;/activity&gt;
</code></pre>
<p>对于 Android 7.1 及更低版本，请在 <code>&lt;application&gt;</code>元素中添加一个 名为 <code>android.max_aspect</code> 的 <code>&lt;meta-data&gt;</code> 元素。</p>
<pre><code class="language-xml">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --&gt;
&lt;!-- Use a letterbox on screens larger than 2.4 --&gt;
&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.4&quot; /&gt;
</code></pre>
<p>如果设置了最大长宽比，请勿忘记同时设置 <code>android:resizeableActivity false</code>。</p>
<blockquote>
<p>有些设备支持分屏模式（同屏多应用）下使用，并且许多应用还支持可调整大小。如果不希望自己的应用支持该模式的话，可以为整个应用或特定 Activity 明确设置 <code>android:resizeableActivity flase</code>属性。</p>
<blockquote>
<p>分屏模式只适用于在 Android 7.0（API 级别 24）或更高版本中运行的所有应用，并且应用默认可调整大小。</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>注⚠️：<strong>如果您的应用不可调整大小，您应该在尽可能多的设备上测试它的行为。 检查所有控件是否均可见。 因为有些设备可让用户</strong>强制</strong>应用进入全屏显示，这会调整这些应用的大小。</p>
</blockquote>
</li>
<li>
<p>声明最大屏幕尺寸<br></p>
<p>​	即使并未完全优化您的应用以<a href="https://developer.android.google.cn/training/multiscreen/screensizes.html">支持不同的屏幕尺寸</a>，Android 仍然可以拉伸大部分应用以适应较大的屏幕。 因此，<strong>几乎从来都没有必要</strong>声明最大屏幕尺寸。</p>
<p>​	不过如果对于 Android 调整应用以适应大屏幕的方式不满意，则可通过在 <code>&lt;supports-screens&gt;</code> 清单标记中指定 <a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#largestWidth"><code>largestWidthLimitDp</code></a> 属性来禁止将大小调整到超出特定宽度。 然后，Android 会启用<a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#compat-mode">屏幕兼容模式</a>（此模式会按照应用支持的最大尺寸屏幕上的绘制方式来绘制布局，然后<strong>放大所有像素以填充屏幕</strong>），<strong>而不是调整布局的大小</strong>。</p>
</li>
<li>
<p>限制应用仅支持平板电脑或电视<br></p>
<p>​	可以使用<code>&lt;supports-screens&gt;</code> <code>manifest</code>元素来阻止手机设备下载您的应用。<br>	例如，以下代码声明只有大屏幕和特大屏幕才能安装您的应用：</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;supports-screens android:smallScreens=&quot;false&quot;
                      android:normalScreens=&quot;false&quot;
                      android:largeScreens=&quot;true&quot;
                      android:xlargeScreens=&quot;true&quot;/&gt;
    ...
&lt;/manifest&gt;
</code></pre>
</li>
<li>
<p>限制应用仅支持特定尺寸和密度<br></p>
<p>​	可以使用<code>&lt;compatible-screens&gt;</code>manifest 元素来定义应用支持的确切屏幕尺寸和密度。 但是，<strong>强烈建议不要</strong>使用此功能，因为未指定的任何尺寸和密度组合都会被视为与应用不兼容的屏幕配置。<br>	<code>&lt;compatible-screens&gt;</code>元素必须包含一个或多个 <code>&lt;screen&gt;</code> 元素。 每个 <code>&lt;screen&gt;</code> 元素都使用 <code>android:screenSize</code> 和 <code>android:screenDensity</code> 属性指定与您的应用兼容的屏幕配置 。 每个 <code>&lt;screen&gt;</code> 元素都<strong>必须同时包含这两个属性</strong>才能指定一个屏幕配置 — 缺少任一属性都会导致该元素无效。<br>	例如，如果您的应用仅与小屏幕尺寸和标准屏幕尺寸（以及一部分屏幕密度）兼容，则 manifest 项将如下所示：</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;compatible-screens&gt;
        &lt;!-- all small size screens --&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;ldpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;mdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;hdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;xhdpi&quot; /&gt;
        &lt;!-- all normal size screens --&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;ldpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;mdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;hdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;xhdpi&quot; /&gt;
    &lt;/compatible-screens&gt;
    ...
    &lt;application ... &gt;
        ...
    &lt;application&gt;
&lt;/manifest&gt;
</code></pre>
<p>未在此处明确声明的任意尺寸和密度组合都将受到限制，无法安装该应用。</p>
</li>
</ol>
<h2 id="多种-apk-支持选修"><a href="https://developer.android.google.cn/google/play/publishing/multiple-apks">多种 APK 支持（选修）</a></h2>
<p>​	依赖 Google Play 平台，故选修。</p>
<h2 id="支持不同平台版本">支持不同平台版本</h2>
<h3 id="运行时检查系统版本">运行时检查系统版本</h3>
<p>​	Android 在 Build constant 类中为每个平台版本都提供了独特的代码，在应用中使用这些代码来构建条件，以确保可用这些 API 时才会去执行这些代码。<br>	例如：</p>
<pre><code class="language-java">private void setUpActionBar() {
    // Make sure we're running on Honeycomb or higher to use ActionBar APIs
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
    }
}
</code></pre>
<blockquote>
<p>注：解析 xml 资源时，Android会自动忽略当前设备不支持的 xml 属性。也就是说，对于 xml 资源而言，不需要担心新的属性在旧版本设备上崩溃或报错，因为旧设备会自动忽略掉不认识的属性，不需要像代码一样提前判断版本再操作。</p>
<p>例如： 如果您设置targetSdkVersion =“11”，则默认情况下，您的应用会在Android 3.0及更高版本中包含ActionBar。如果要在 ActionBar 中添加菜单项，您需要在菜单资源 XML 中设置<code>android：showAsAction =“ifRoom”</code>。 而在跨版本的 XML 文件中执行此操作是安全的，因为旧版本的 Android 因为不认识 showAsAction 属性而会忽略掉它（也就是说，您不需要专门区分出一个<code>res/menu-v11/</code>）。</p>
</blockquote>
<h3 id="使用不同主题样式">使用不同主题样式</h3>
<p>​	Android 提供了许多主题样式，可以在 manifest 清单文件中自定义。当你使用了这些主题后，你的应用会自动适配为 Android 最新版的外观和感觉样式。</p>
<p>想让你的 Activity 看起来像个对话框：</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@android:style/Theme.Dialog&quot;&gt;
</code></pre>
<p>想让你的 Activity 有个透明的背景：</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@android:style/Theme.Translucent&quot;&gt;
</code></pre>
<p>想让你的活动使用你自己的主题（自定义主题需要放在 <code>/res/values/styles.xml</code>下）</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@style/CustomTheme&quot;&gt;
</code></pre>
<p>想让你的整个应用所有 Activity 都使用某种主题，在<code>&lt;application&gt;</code>中添加<code>android:theme</code> 属性即可</p>
<pre><code class="language-xml">&lt;application android:theme=&quot;@style/CustomTheme&quot;&gt;
</code></pre>
<p>更多的自定义主题设计可以看<a href="https://developer.android.google.cn/guide/topics/ui/themes.html">风格主题向导</a></p>
<h2 id="google-play-上的过滤器选修">Google Play 上的过滤器（选修）</h2>
<p>使用场景：当用户在 Google Play 上搜索或浏览应用以下载时，会根据哪些应用与其设备兼容来过滤搜索结果。</p>
<h1 id="android-wear"><a href="https://developer.android.google.cn/training/wearables">Android Wear</a></h1>
<h1 id="android-tv"><a href="https://developer.android.google.cn/training/tv">Android TV</a></h1>
<h1 id="android-auto"><a href="https://developer.android.google.cn/training/auto">Android Auto</a></h1>
<h1 id="android-things"><a href="https://developer.android.google.cn/things/get-started">Android Things</a></h1>
<h1 id="chrome-os-devices"><a href="https://developer.android.google.cn/chrome-os/intro">Chrome OS Devices</a></h1>
<h1 id="核心内容-eng-日后填坑"><a href="https://developer.android.google.cn/guide/components/activities/intro-activities">核心内容 Eng 日后填坑</a></h1>
<h1 id="完美测试-eng-日后填坑"><a href="https://developer.android.google.cn/training/testing">完美测试 Eng 日后填坑</a></h1>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://ArsenicX.github.io/android/" class="tag">
                    Android
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://ArsenicX.github.io/github-page-jekyll-da-jian/">
                  <h3 class="post-title">
                    Github Page + jekyll搭建
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
