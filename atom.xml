<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ArsenicX.github.io/</id>
    <title>ArsenicX</title>
    <updated>2020-02-18T07:44:34.581Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ArsenicX.github.io/"/>
    <link rel="self" href="https://ArsenicX.github.io/atom.xml"/>
    <logo>https://ArsenicX.github.io/images/avatar.png</logo>
    <icon>https://ArsenicX.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ArsenicX</rights>
    <entry>
        <title type="html"><![CDATA[我的收藏]]></title>
        <id>https://ArsenicX.github.io/wo-de-shou-cang</id>
        <link href="https://ArsenicX.github.io/wo-de-shou-cang">
        </link>
        <updated>2020-02-14T12:01:14.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;我的收藏&quot;</p>
<p>date:   2019-03-26 10:06:38<br>
categories: Android<br>
comments: false</p>
<hr>
<p><a href="https://www.zhihu.com/question/20400700/answer/117464182">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？ - 胖君的回答</a></p>
<p>学习路线总结：https://mp.weixin.qq.com/s/y5SaYprZJqhUmWy8a9qkKQ</p>
<p><br>Material Design - FloatingActionMenu：https://www.jianshu.com/p/6489d255b0a6<br>
<br>技术文章汇总：https://mp.weixin.qq.com/s/CrriyKC8nUgpx6exH8X1dA<br>
<br>Android内存泄露：https://www.jianshu.com/p/e719e0c397e5<br>
<br>Android字体适配：https://www.jianshu.com/p/2fdc97ae74a8<br>
<br>五大常用算法：https://blog.csdn.net/ling_wang/article/details/81560925</p>
<h2 id="面试">面试</h2>
<p><a href="https://blog.csdn.net/huangqili1314/article/details/72792682">17-18 Android面试题 </a><br><br>
<a href="https://github.com/JsonChao/Awesome-Android-Interview">Android 面试知识点 </a><br><br>
<a href="https://www.jianshu.com/p/c44d7a106302">入门Android的一点一滴</a><br><br>
<a href="https://www.jianshu.com/p/0f72ac621f82">Android面试总结 (BAT等6家offer)</a><br></p>
<p><a href="https://github.com/JsonChao/Awesome-Third-Library-Source-Analysis">流行框架解析 </a><br><br>
<a href="https://www.ctolib.com/cheatsheets-Android-ch.html">常见流行框架</a><br><br>
<a href="https://developer.android.google.cn/guide/components/fundamentals">Google Android开发文档</a><br><br>
<a href="https://github.com/Blankj/AndroidStandardDevelop">开发规范</a><br></p>
<p><a href="https://crossoverjie.top/JCSprout/#/">Java 核心知识库</a><br></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BaseActivity & MyApplication]]></title>
        <id>https://ArsenicX.github.io/baseactivity-and-myapplication</id>
        <link href="https://ArsenicX.github.io/baseactivity-and-myapplication">
        </link>
        <updated>2020-02-14T11:58:19.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;BaseActivity &amp; MyApplication&quot;</p>
<p>date:   2019-03-27 11:31:20<br>
categories: Android<br>
comments: false</p>
<hr>
<p><a href="https://juejin.im/post/5959b5bcf265da6c4d1bb245">GreenDao3.2 使用教程</a></p>
<pre><code class="language-java">public class MyApplication extends Application {

    private DaoSession daoSession;

    @Override
    public void onCreate() {
        super.onCreate();
        DaoMaster.DevOpenHelper helper = new  DaoMaster.DevOpenHelper(this, &quot;myDB.db&quot;);
        Database db =  helper.getWritableDb();
        daoSession = new DaoMaster(db).newSession();
    }

    public DaoSession getDaoSession() {
        return daoSession;

    }
}

</code></pre>
<pre><code class="language-java">public class BaseActivity extends AppCompatActivity {

    private static final String TAG = BaseActivity.class.getSimpleName();
    //private static final String TAG = &quot;my&quot;;

    /**
     * [简化Toast]
     * @param msg
     */
    public void showToast(String msg){
        Toast.makeText(this,msg, Toast.LENGTH_SHORT).show();
    }

    /**
     * [简化Log]
     * @param s
     */
    public void elog(String s) {
        Log.e(TAG, s);
    }

    /**
     * [简化Log]
     * @param s
     * @param e
     */
    public void eloge(String s,Exception e) {
        Log.e(TAG, s, e);
    }

    /**
     * [页面跳转]
     * @param clz
     */
    public void startActivity(Class&lt;?&gt; clz) {
        startActivity(new Intent(BaseActivity.this,clz));
    }

    /**
     * [携带数据的页面跳转]
     * @param clz
     * @param bundle
     */
    public void startActivity(Class&lt;?&gt; clz, Bundle bundle) {
        Intent intent = new Intent();
        intent.setClass(this, clz);
        if (bundle != null) {
            intent.putExtras(bundle);
        }
        startActivity(intent);
    }

    /**
     * [含有Bundle通过Class打开编辑界面]
     * @param cls
     * @param bundle
     * @param requestCode
     */
    public void startActivityForResult(Class&lt;?&gt; cls, Bundle bundle,
                                       int requestCode) {
        Intent intent = new Intent();
        intent.setClass(this, cls);
        if (bundle != null) {
            intent.putExtras(bundle);
        }
        startActivityForResult(intent, requestCode);
    }


}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[callback]]></title>
        <id>https://ArsenicX.github.io/callback</id>
        <link href="https://ArsenicX.github.io/callback">
        </link>
        <updated>2020-02-14T11:57:12.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;Android 回调机制举例及个人理解&quot;</p>
<p>date:   2019-03-26 10:06:38<br>
categories: Android<br>
comments: false</p>
<hr>
<h4 id="先举1个java的例子用来引入"><strong>先举1个Java的例子用来引入</strong></h4>
<p>小王去向小李请教数学题，小李在判断完小王的问题后将结果返回给小王：</p>
<pre><code class="language-java">//这个是回调接口，在小李返回结果给小王时要用到
public  interface CallBack {
    void solve(String result);
}
</code></pre>
<pre><code class="language-java">//这个是小王，重写了solve方法
public class Wang implements CallBack {
    private Li li;

    public Wang(Li li) { this.li = li; }

    public void ask(String question){
        li.answer(Wang.this , question);
    }

	//此处的solve()便是回调方法，可以在其他类中调用
    @Override
    public void solve(String result) {
        System.out.println(&quot;答案是:&quot;  + result);
    }
}
</code></pre>
<pre><code class="language-java">//这个是小李，判断完问题之后将答案通过callBack.solve返回给小王
public  class Li {
    public  void answer(CallBack callBack, String question){
        String result = &quot;不知道&quot;;

        System.out.println(&quot;问题是：&quot; + question);
        if(question.equals(&quot;1+1=?&quot;))    result = &quot;2&quot;;
        else if(question.equals(&quot;1+2=?&quot;))   result = &quot;3&quot;;

        callBack.solve(result);
    }
}
</code></pre>
<pre><code class="language-java">测试类
public  class Test {
    public  static  void main(String[]args){
        Li li = new  Li();
        Wang wang = new  Wang(li);
        wang.ask(&quot;1+1=?&quot; );
    }
}
</code></pre>
<p>此例如果能看懂就不必再深究了，这里只是为了引入<br>
直接看下面的Android的实际例子<br>
<br><br></p>
<h4 id="简单需求点击fragment的button改变mainactivity中textview的显示"><strong>简单需求：点击Fragment的Button，改变MainActivity中TextView的显示</strong><img src="https://img-blog.csdnimg.cn/20190325171613639.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fyc2VuaWNfVHVjbw==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></h4>
<pre><code class="language-java">//定义接口
public interface CallBackListener {
    void onCallBack();
}
</code></pre>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity implements CallBackListener {

    int i = 0;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

	//根据自定义需求重写方法
    @Override
    public void onCallBack() {
        TextView textView = findViewById(R.id.textView);
        textView.setText(&quot;点击了&quot; + i + &quot;次&quot;);
        i++;
    }
}
</code></pre>
<pre><code class="language-java">public class CallBackFragment extends Fragment {

    private CallBackListener callBackListener;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment, container, false);
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        
        if (getActivity() instanceof CallBackListener)
            callBackListener = (CallBackListener) getActivity();
    }

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInst17:35 2019/4/8anceState);

        Button btn = (Button) view.findViewById(R.id.button);
        btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if(callBackListener != null)
                    callBackListener.onCallBack();
            }
        });
    }
}
</code></pre>
<blockquote>
<p>onCreateView和onViewCreated的区别：<strong>日常使用没区别：）</strong><br>
<br>onCreateView可能会（极少）在绘制子View（TextView、Button等除了主Layout的其他控件）的时候崩溃，这时可以尝试在onCreateView中初始化主Layout，而在onViewCreated中使用findViewById初始化其他控件。<br>
调用顺序：onViewCreated()会在onCreateView()之后立马被调用<br>
<br>来源：<a href="https://stackoverflow.com/questions/25119090/difference-between-oncreateview-and-onviewcreated-in-fragment">stackoverflow</a></p>
</blockquote>
<p><br><br><br>
综上2个例子，以下是我<strong>个人的理解和想法</strong></p>
<ol>
<li>
<p>首先创建一个接口L（如上例的CallBack或CallBackListener），并在其中添加你想要的效果（ solve() 或 onCallBack() ）。这个接口可以创建在外面，也可以创建在某个类中</p>
</li>
<li>
<p>哪个类想要实现这个效果，这个效果最终体现在哪个类上面，就让这个类继承前面定义好的那个接口（如果这个接口是单独新建的<sup>情况1</sup>），或者在这个类中new出接口并重写方法（如果这个接口是新建在其他类中的<sup>情况2</sup>）</p>
<p>情况1: 你想让小王去输出结果（因为如果是小王输出的话就说明小王拿到了结果），就让Wang继承CallBack；你想让MainActivity中的Textview显示点击次数，那就让MainActivity继承CallBackListener。<br>
情况2: 假设CallBack接口是定义在类A中的，而你想要B类去实现你要的效果。</p>
<pre><code class="language-java">public class A {
	public void add(MyCallBack myCallBack){
    	myCallBack.complete();
	}

	public interface MyCallBack{
    	void complete();
   		};
   	}
</code></pre>
<pre><code class="language-java">public class B {
	A a = new A();

	public void test(){
    	a.add(new A.MyCallBack(){
    		@Override
    		public void complete() {
    		//自定义效果
    		}
    	});
   		};
   	}
</code></pre>
</li>
<li>
<p>第二步中你想要的那个效果，是谁导致的，是谁触发的，就在谁中引用<br>比如：小王拿到结果是由于小李将答案传给了小王，所以小李就需要通过answer()中的callback获取到小王的引用，通过callBack.solve把resul传给小王；MainActivity中TextView变化是由于Fragment中Button的点击，所以在Fragment中，首先通过getActivity()获取到MainActivity，然后在Button的点击事件中调用onCallBack()方法达到效果；自定义效果是在调用a.add时触发的，所以就在类A中引用，即myCallBack.complete()（情况二这种情况，一般引用的类和接口定义的类是同一个类）<br>
<br><br></p>
</li>
</ol>
<p>这时候就要考虑为什么需要有Callback的存在，它的意义是什么<br>
在Java学习中我们就知道了，接口的作用是「<strong>我想要一个XX效果，但是我目前实现不出来，或者说实现的不完全，那就把它定义成一个接口，让下面会用到这个效果的类去继承，然后再根据自己的情况去重调代码</strong>」<br>
我们这时候举例，假如这个我们想要的效果就是<strong>点击事件</strong></p>
<h4 id="button原生的点击事件">Button原生的点击事件</h4>
<pre><code class="language-java">package android.view;

public interface OnClickListener {
	void  onClick(View v);
	//省去了其他代码
}  
</code></pre>
<pre><code class="language-java">//MainActivity类
public  class MainActivity  extends Activity implements  OnClickListener{  
	private  Button button;  
    
	@Override   
	public void onCreate(Bundle savedInstanceState) {  
		super .onCreate(savedInstanceState);  
		setContentView(R.layout.activity_main);  
		button = (Button)findViewById(R.id.button1);  
		button.setOnClickListener(this);  
	}  

	@Override   
	public void onClick(View v) {
		//这里写你想要效果
	}  
}  
</code></pre>
<pre><code class="language-java">//参见‘个人的理解和想法’第三点
//因为这个效果的直接来由是「我点击了View」 (Button隶属View)，所以需要在View类中获取MainActivity并去调用MainActivity的onClick()方法
public class View implements Drawable.Callback, KeyEvent.Callback,AccessibilityEventSource {
	public OnClickListener mOnClickListener;

    public void setOnClickListener(@Nullable OnClickListener l) {
        if (!isClickable()) {
            setClickable(true);
        }
        
        //获取到了MainActivity，类似于例2中的getActivity()
        getListenerInfo().mOnClickListener = l;
    }
    
	public boolean performClick() {
		if (li != null &amp;&amp; li.mOnClickListener != null) {
		playSoundEffect(SoundEffectConstants.CLICK);
		
		//点击事件，这里即是「回调」
		li.mOnClickListener.onClick(this);
		result = true;
		} 
    }
    //省去了其他代码
}
</code></pre>
<blockquote>
<p>具体分析可以看<a href="https://www.jianshu.com/p/3f86b7949f20">简书</a></p>
</blockquote>
<p><br><br><br>
由上总结，回调其实就是：</p>
<h4 id="a调用b的方法b需要传入a自身引用或通过其他方式-getactivity-拿到a的引用在方法b执行完毕之后再利用拿到的a的引用来调用a中的方法">A调用B的方法b，需要传入A自身引用，或通过其他方式( getActivity() )拿到A的引用，在方法b执行完毕之后，再利用拿到的A的引用，来调用A中的方法</h4>
<p><br>以上为个人理解，如果有哪里各位dalao觉得不对或者可以改进的希望可以提出，如果有疑惑想要一起交流的也同样欢迎🙆<br>
<br><br></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2-ways-to-make-recycler-layout]]></title>
        <id>https://ArsenicX.github.io/TgJUKArZW</id>
        <link href="https://ArsenicX.github.io/TgJUKArZW">
        </link>
        <updated>2020-02-14T11:56:16.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;两种方式实现RecyclerView多布局&quot;</p>
<p>date:   2019-01-18 19:42:38<br>
categories: Android<br>
comments: false</p>
<hr>
<h2 id="方式一实现效果br">方式一实现效果：<br><img src="https://i.loli.net/2019/04/08/5cab1518a8f3a.jpg" alt="20190118191204387.jpg" loading="lazy"></h2>
<h3 id="具体思路步骤">具体思路步骤：</h3>
<ol>
<li>
<p>子项有3种类型, 分别是TextView+EditView, TextView+RadioGroup, TextView+imageView. 且除第1、2项外还有点击事件</p>
</li>
<li>
<p>新建3个item.xml供不同种子项使用</p>
</li>
<li>
<p>createHolder时判断子项类型而调用不同的item.xml</p>
</li>
</ol>
<h3 id="代码实现">代码实现：</h3>
<p>1.首先创建Item实体并加入自定义属性</p>
<pre><code class="language-java">public class ItemEntity {
    public String title;dd&gt;&lt;br/&gt;&lt;br&gt;&lt;br/&gt;&lt;/br&gt;
    public int type; //1代表子项1, 2代表子项2, 3代表子项剩余其他
}
</code></pre>
<p>2.Activity中添加数据<br></p>
<pre><code class="language-java">List&lt;ItemEntity&gt; itemList = new ArrayList&lt;&gt;();  

ItemEntity i0 = new ItemArrange();
i0.title = &quot;方案名称&quot;;
i0.type = 0;  

itemList.add(i0);
ItemEntity i1 = new ItemArrange();
i1.title = &quot;性别&quot;;
i1.type = 1;
itemList.add(i1);
</code></pre>
<p>3.ItemAdapter<br></p>
<pre><code class="language-java">public class ItemAdapter extends RecyclerView.Adapter&lt;ItemAdapter.ViewHolder&gt;{
    private List&lt;ItemEntity&gt; itemList = new ArrayList&lt;&gt;();
    public ItemAdapter(List&lt;ItemEntity&gt; mItemList) {
        itemList = mItemList;
    }
 
    @Override
    public ItemAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        ItemAdapter.ViewHolder holder = null;
        switch (viewType){
            case 1:
                holder = new ItemAdapter.ViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false));
                break;
            case 2:
                holder = new ItemAdapter.ViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_2, parent, false));
                break;
            case 3:
                holder = new ItemAdapter.ViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_3, parent, false));
                break;
            }
        return holder;
    }
 
    @Override
    public void onBindViewHolder(final ViewHolder holder, final int position) {
        final ItemEntity item = itemList.get(position);
        holder.tvTitle.setText(itemList.get(position).title);
        holder.itemView.setOnClickListener(new View.OnClickListener() {
        
        @Override
        public void onClick(View v) {
            ... 
            //除了第一、二项外，其他项需要点击事件，可以ItemEntity再加个属性进行判断
        }
    }
 
    @Override
    public int getItemViewType(int position) {
        //在第一次createHolder时会调用
        return itemList.get(position).type;
    }
 
 
    ...
 
}
</code></pre>
<br>
<br>
<h2 id="方式二实现效果br">方式二实现效果：<br><img src="https://i.loli.net/2019/04/08/5cab1518ad112.jpg" alt="20190314141823761.jpg" loading="lazy"></h2>
<blockquote>
<p>方式一适用于子项部件差异不大的情况, 代码比较简略<br>如果出现的组件种类过多, 不适合创建一个实例将所有种类写进去. 则可以用方式二</p>
</blockquote>
<pre><code class="language-java">static List&lt;item&gt; itemList;
public void initList(){
    itemList = new ArrayList&lt;&gt;();
    item i1 = new item(R.drawable.ic_reminder,&quot;声音与提醒&quot;);
    itemList.add(i1);
    item i2 = new item(R.drawable.ic_help,&quot;帮助&quot;);
    itemList.add(i2);
    item i3 = new item(R.drawable.ic_info,&quot;关于&quot;);
    itemList.add(i3);
}
class item{
    int itemIconId;
    String itemText;
    public item(int itemIconId,String itemText){
        this.itemIconId = itemIconId;
        this.itemText = itemText;
    }
}
 
 
class itemAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;{
    //总共有3种类型布局，登录、间隔、设置项
    final static int AVATAR = 0;
    final static int SETTING = 1;
    final static int INTERVAL = 2;
 
    public itemAdapter(){ }
    @NonNull
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) {
        switch(viewType){
            case AVATAR:
                View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item_avatar, viewGroup, false);
                return new avatarHolder(view);
            case INTERVAL:
                View view1 = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item_interval, viewGroup, false);
                return new intervalHolder(view1);
            default:
                View view2 = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item_setting, viewGroup, false);
                return new settingHolder(view2);
        }
    }
    @Override
    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder viewHolder, int position) {
        //因为头像布局和间隔布局是固定格式的，所以只需要给每个设置项绑定就可以了
        if(viewHolder instanceof settingHolder) setSettingHolder((settingHolder)viewHolder,position);
    }
    @Override
    public int getItemCount() {
        //设置项的个数 + 3（1个登录项 + 2个间隔项）
        return itemList.size() + 3;
    }
    @Override
    public int getItemViewType(int position) {
        switch (position){
            case 0: return AVATAR;
            case 1:
            case 3: return INTERVAL;
            default:return SETTING;
        }
    }
    class avatarHolder extends RecyclerView.ViewHolder{
        public avatarHolder(@NonNull View itemView) {
            super(itemView);
        }
    }
    class intervalHolder extends RecyclerView.ViewHolder{
        public intervalHolder(@NonNull View itemView) {
            super(itemView);
        }
    }
    class settingHolder extends RecyclerView.ViewHolder{
        ImageView imageView;
        TextView textView;
        public settingHolder(@NonNull View itemView) {
            super(itemView);
            imageView = itemView.findViewById(R.id.imageview);
            textView = itemView.findViewById(R.id.textView);
        }
    }
    public void setSettingHolder(settingHolder viewHolder, int position){
        switch (position){
            //注意每个设置项在RV和在itemList中的position是不一定相同的
            case 2:
                viewHolder.imageView.setImageResource(itemList.get(0).itemIconId);
                viewHolder.textView.setText(itemList.get(0).itemText);
                break;
            case 4:
                viewHolder.imageView.setImageResource(itemList.get(1).itemIconId);
                viewHolder.textView.setText(itemList.get(1).itemText);
                break;
            case 5:
                viewHolder.imageView.setImageResource(itemList.get(2).itemIconId);
                viewHolder.textView.setText(itemList.get(2).itemText);
                break;
        }
        //viewHolder.itemView.setOnClickListener(new View.OnClickListener() {...}
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HttpUrlConnection]]></title>
        <id>https://ArsenicX.github.io/OK_0VQYPX</id>
        <link href="https://ArsenicX.github.io/OK_0VQYPX">
        </link>
        <updated>2020-02-14T11:55:07.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;HttpURLConnection的post提交请求&quot;</p>
<p>date:   2019-01-07 17:51:54</p>
<p>categories: Android<br>
comments: false</p>
<hr>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
 
public class HttpURLConnectionPost extends AppCompatActivity {
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_action);
        
        new Thread() {
            @Override
            public void run() {
                super.run();
                postRequest();
            }
        }.start(); 
    }
 
    public void postRequest(){
        BufferedReader reader = null;
        HttpURLConnection conn= null;
 
        try{
            URL postUrl = new URL(&quot;http://www.123.cn&quot;); //Post请求的url，与get不同的是不需要带参数
            conn= (HttpURLConnection) postUrl.openConnection(); //打开连接
            conn.setDoOutput(true); //是否向conn输出. 因为是post请求, 参数要放在http正文内, 所以设为true
            conn.setDoInput(true); //是否从conn读,默认为true, 具体说明见下面#1
            conn.setRequestMethod(&quot;POST&quot;); //默认是 GET方式
            conn.setUseCaches(false); //Post 请求不能使用缓存
            connection.setConnectTimeout(5000);
            conn.setInstanceFollowRedirects(true); //设置本次连接是否自动重定向
            conn.setConnectTimeout(5000);
            conn.setRequestProperty(&quot;&quot;,&quot;&quot;); //配置本次连接的Content-type, 具体说明见下面#2
            // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成,
            // 要注意的是conn.getOutputStream会隐式的进行connect
            conn.connect();
 
            DataOutputStream out = new DataOutputStream(conn.getOutputStream());
            String content = &quot;account=&quot; + name + &quot;&amp;age=&quot; + age; //Post参数, 用法和get类似
            out.writeBytes(content); //提交
            out.flush(); //关闭流
            out.close();
 
            if(connection.getResponseCode() == 200) //200代表成功, 见下面#3
            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            else reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));
            String line;
            while ((line = reader.readLine()) != null){
                System.out.println(line);
            }
 
            //如果有更复杂的操作可以发送message, 如:
            //Message m = new Message();
            //handler.sendMessage(m);
 
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try{
                if(reader != null) reader.close();
                if(conn != null) conn.disconnect();
            }catch (Exception e){
                e.printStackTrace();
            }
        }
 
    }
}
</code></pre>
<h2 id="1-setdooutput与setdoinput的区别">1. <a href="https://blog.csdn.net/u010665691/article/details/45558119">setDoOutput与setDoInput的区别</a></h2>
<h2 id="2-setrequestpropertybr">2. setRequestProperty<br></h2>
<p>setRequestProperty一般用来设置通讯的头部信息，设置访问方式等。<br><br>
也就是告诉服务器,你的客户端的配置/需求<br> <br></p>
<p>比如说你要取某个文件的多少字节到多少字节就通过这个东西告诉服务器<br>
<br>你的客户端支持压缩, 也可以告诉服务器, 服务器会压缩传输<br>
<br>你的客户端支持什么编码, 也可以告诉服务器, 服务器会尽量按照你的编码传递数据<br><br>
你的客户端是什么类型, IE、Firefox等等, 有的服务器会按照你的客户端类型给你传送文本<br> <br></p>
<p>如果什么都不是, 服务器就会按缺省配置传递内容给你的客户端</p>
<h2 id="3-常见http状态码">3. <a href="https://blog.csdn.net/luolinghong_csdn/article/details/78404409">常见HTTP状态码</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Exception总结]]></title>
        <id>https://ArsenicX.github.io/WcEfGlHKN</id>
        <link href="https://ArsenicX.github.io/WcEfGlHKN">
        </link>
        <updated>2020-02-14T11:53:43.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;Android 自学杂记－异常&quot;</p>
<p>date:   2018-08-17 23:52:36<br>
categories: Android<br>
comments: false</p>
<hr>
<ul>
<li>
<p>活动Activity死活不能全屏<br>
<br> 可能是设置了android:theme=&quot;@style/Theme.AppCompat.Dialog&quot;</p>
</li>
<li>
<p>Caused by: org.litepal.exceptions.InvalidAttributesException: dbname is empty or not defined in litepal.xml file<br>
<br> assets 目录下的 litepal 忘了加后缀</p>
</li>
<li>
<p>'android.view.Window$Callback android.view.Window.getCallback()' on a null object reference<br>
<br> findViewById 不能在 setContentView(R.layout.activity_main) 的前面</p>
</li>
<li>
<p>Recyclerview 子项间距差了一个 match_parent 距离<br>
<br> Recyclerview 的 item 视图时，把 layout_height 写成 match_parent</p>
</li>
<li>
<p>listview 滚动时顶部不能填充<br>
<br> 添加配置android:clipToPadding=&quot;false&quot;<br>
<br> 参考：<a href="https://blog.csdn.net/litefish/article/details/52471273">clipToPadding和clipChildren</a></p>
</li>
<li>
<p>java.lang.NullPointerException: Attempt to get length of null array<br>
<br> 添加读写SD卡的权限, 另外记得权限申请需要放在读写操作之前</p>
</li>
</ul>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEM&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
</code></pre>
<ul>
<li>'Receiver has no zero argument constructor'<br>
<br> 出现环境: MainActivity中构造内部类MyBroadcastReceiver, 静态注册MyBroadcastReceiver, TestActivity调用sendBroadcast<br>
<br> 解决方案:</li>
</ul>
<ol>
<li>如果是静态广播注册方式 + 广播作为内部类来使用：广播内部类声明为static类型。</li>
<li>如果是非静态广播注册方式：广播必须在类中注册（调用registerReceiver()方法）、注销（调用unregisterReceiver()方法）。</li>
</ol>
<ul>
<li>编译不通过<br>
<br> 添加其他仓库</li>
</ul>
<pre><code class="language-java">allprojects {
    repositories {
        jcenter()
        maven {
            url &quot;https://maven.google.com&quot;
        }
        google()
        mavenCentral() 
        mavenLocal()
    }
}
</code></pre>
<ul>
<li>Circular dependency between the following tasks</li>
</ul>
<pre><code class="language-java">编译错误提示: 
Circular dependency between the following tasks:
:app:checkManifestChangesDevelopDebug
\--- :app:instantRunMainApkResourcesDevelopDebug
     \--- :app:transformClassesAndDexWithShrinkResForDevelopDebug
          \--- :app:transformDexArchiveWithDexMergerForDevelopDebug
               +--- :app:preColdswapDevelopDebug
               |    \--- :app:incrementalDevelopDebugTasks
               |         +--- :app:transformClassesAndClassesEnhancedWithInstantReloadDexForDevelopDebug
               |         |    \--- :app:transformClassesWithInstantRunForDevelopDebug
               |         |         \--- :app:checkManifestChangesDevelopDebug (*)
               |         \--- :app:transformClassesWithInstantRunForDevelopDebug (*)
               \--- :app:transformClassesWithDexBuilderForDevelopDebug
                    +--- :app:preColdswapDevelopDebug (*)
                    \--- :app:transformClassesWithInstantRunForDevelopDebug (*)

(*) - details omitted (listed previously)

</code></pre>
<p><br>  解决方法1: 把instant run关了</p>
<p><br>  解决方法2: build.gradle (Module: app) 中 添加如下配置, 详见: Circular dependency between the following tasks</p>
<pre><code class="language-java">buildTypes {
        debug {
            minifyEnabled true
            useProguard true
            shrinkResources true
            ...
            } 
        ...
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 总结]]></title>
        <id>https://ArsenicX.github.io/FN7wCWhMr</id>
        <link href="https://ArsenicX.github.io/FN7wCWhMr">
        </link>
        <updated>2020-02-14T11:53:04.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;Android 自学杂记&quot;</p>
<p>date:   2018-08-17 23:52:36<br>
categories: Android<br>
comments: false</p>
<hr>
<h2 id="component">component：</h2>
<ul>
<li>
<h3 id="edittext">EditText</h3>
</li>
</ul>
<pre><code class="language-html">//去掉自带下划线
android:background=&quot;@null&quot;

//Hint字体效果
android:textColor=&quot;#FFF&quot;
android:textColorHint=&quot;#C2C2C2&quot;
android:textCursorDrawable=&quot;@null&quot;

//光标从右边/中间输入
//因为gravity代表了光标的位置,所以就不能通过gravity来控制Hint在EditView中的位置了,只能用layout_marginTop曲线救国
android:gravity=&quot;right/center&quot; 或者 editText.setGravity(Gravity.RIGHT/CENTER);
</code></pre>
<br>
<ul>
<li>
<h3 id="textview">TextView</h3>
</li>
</ul>
<pre><code class="language-html">//跑马灯效果
android:singleLine=&quot;true&quot; 
android:ellipsize=&quot;marquee&quot; 
android:marqueeRepeatLimit=&quot;marquee_forever&quot;/&gt;

textView.setSelected(true);
</code></pre>
<br>
<ul>
<li>
<h3 id="自定义alertdialog">自定义AlertDialog</h3>
</li>
</ul>
<pre><code class="language-html">LayoutInflater inflater = LayoutInflater.from(this);
View v = inflater.inflate(R.layout.my_dialog, null);

AlertDialog.Builder builder= new AlertDialog.Builder(this,R.style.MyDialogStyle);
final Dialog dialog= builder.create();
dialog.show();
dialog.getWindow().setContentView(v); //自定义布局要在dialog.show()的后面
//dialog.getWindow().setGravity(Gravity.CENTER); //可以设置显示的位置，默认居中


Button btn= v.findViewById(R.id.btn);
btn.setOnClickListener(...);
</code></pre>
<pre><code class="language-html">&lt;style name=&quot;MyDialogStyle&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;
        &lt;!--背景颜色和透明程度--&gt;
        &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
        &lt;!--是否浮现在activity之上--&gt;
        &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
        &lt;!--是否去除边框--&gt;
        &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;
        &lt;!--是否模糊--&gt;
        &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;true&lt;/item&gt;
        &lt;!--是否去除标题--&gt;
        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;

        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
        &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<br>
<ul>
<li>
<h3 id="scrollingtabsview-左右滑动切换标签界面">ScrollingTabsView : 左右滑动切换标签界面</h3>
</li>
</ul>
<br>
<ul>
<li>
<h3 id="navigationview">NavigationView :</h3>
</li>
</ul>
<pre><code class="language-html">//修改menu默认选中子项
nv.getMenu().getItem(0).setChecked(true);


//修改menu子项颜色
//新建res/color/selector_nv.xml, 注意一定要在color文件夹下
//注意排序很关键，因为它们是按顺序被评估的，所以default才在最下面
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;item android:state_checked=&quot;true&quot;
          android:color=&quot;@color/colorAccent&quot;&gt;&lt;/item&gt; &lt;!-- selected颜色 --&gt;
    
    &lt;item android:state_pressed=&quot;true&quot;
          android:color=&quot;@color/colorAccent&quot;/&gt; &lt;!-- pressed颜色 --&gt;
    
    &lt;item android:state_focused=&quot;true&quot;
          android:color=&quot;@color/colorAccent&quot;/&gt; &lt;!-- focused颜色 --&gt;
    
    &lt;item android:color=&quot;@color/colorAccent&quot;/&gt; &lt;!-- default颜色 --&gt;

&lt;/selector&gt;


Resources resource = (Resources)getBaseContext().getResources();
ColorStateList csl = resource.getColorStateList(R.color.selector_nv);
nv.setItemTextColor(csl);
</code></pre>
<br>
<ul>
<li>
<h3 id="searchview-更详细可以看-materialdesign之searchview全面解锁">SearchView : 更详细可以看 <a href="https://www.jianshu.com/p/7c1e78e91506">MaterialDesign之SearchView全面解锁</a></h3>
</li>
</ul>
<pre><code class="language-java">//不自动弹出输入法
sv.clearFocus();

//searchView样式
sv.onActionViewExpanded(); //区别不大, 不用多看

Class&lt;?&gt; c = sv.getClass();
    try {
        Field f=c.getDeclaredField(&quot;mSearchPlate&quot;);//通过反射，获得类对象的一个属性对象
        f.setAccessible(true);//设置此私有属性是可访问的
        View v=(View) f.get(sv);//获得属性的值
        v.setBackgroundResource(R.drawable.shape_color_grey);//设置此view的背景
    } catch (Exception e) {
        e.printStackTrace();
    }
        
//搜索事件,返回值默认为false, 有操作则改成true
sv.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
    //输入内容后,点击[搜索]才开始搜索
    @Override
    public boolean onQueryTextSubmit(String s) { return false; }
            
    //搜索框有内容后就自动搜索
    @Override
    public boolean onQueryTextChange(String s) {return false; }
});
</code></pre>
<pre><code class="language-html">//内嵌在toolBar中的SearchView
&lt;item
    android:id=&quot;@+id/search&quot;
    android:actionViewClass=&quot;android.widget.SearchView&quot;
    android:showAsAction=&quot;ifRoom&quot; //ifRoom表示如果有空间就出现,还有always和never选项
    android:title=&quot;搜索&quot;/&gt;
</code></pre>
<br>
<h2 id="style">Style:</h2>
<ul>
<li>
<h3 id="dp-px-dpi">dp / px / dpi</h3>
<p>若一个屏幕分辨率是1920<em>1080<br>则该屏幕长为1920px，宽为1080px，对角线为√（1080</em> 1080+1920*1920）≈  2203px<br>如果屏幕尺寸为5寸，则dpi为2203px / 5 ≈ 441dpi<br>则屏幕长为1920/（441/160）= 697dp，宽为1080/（441/160）= 392dp</p>
</li>
</ul>
<br>
<ul>
<li>
<h3 id="dpi-ppi">dpi &amp; ppi：</h3>
<p>每英寸容纳像素数量，即像素密度（android叫dpi，ios叫ppi（pixels per inch），一个意思）</p>
</li>
</ul>
<blockquote>
<p>iPhone(6~7) 宽为 2.3 英寸，高为 4.1 英寸，根据勾股定理得出这块屏幕的尺寸（屏幕对角线距离）是 4.7 英寸。iPhone(6~7) 屏幕宽（每行）有 750 个像素（发光点），高（每竖）有 1334 颗像素（发光点）。<br> <br>可以知道这台iPhone的分辨率为1334*750，像素密度为1334/4.1 = 750/2.3 ≈ 326ppi</p>
</blockquote>
<pre><code>&lt;br&gt;补充：&lt;br&gt; **脱离屏幕的大小讨论分辨率是没有意义的**
</code></pre>
<p>  现在有一只手机和一台电视，他们都是 1080P 分辨率，拥有 1920 x 1080 个总像素点。但是你觉得手机屏幕好像清楚的不得了，而电视屏幕凑近看全是类似马赛克的点。这是因为因为当屏幕尺寸被放大了，倘若分辨率不变，那么每一颗像素也必须得变大。于是就会造成这样的问题：一个像素点，在你的手机上只有一粒灰尘大小，而在电视上，可能大过一粒米。</p>
<p>  所以光看屏幕的分辨率对于设计师来说是不具备多少实际意义的，通过分辨率计算得出的像素密度（PPI）才是设计师要关心的问题，我们通过屏幕分辨率和屏幕尺寸就能计算出屏幕的像素密度的。</p>
<br>
<ul>
<li>
<h3 id="textviewstyle">TextViewStyle</h3>
</li>
</ul>
<pre><code class="language-html">// 项目中出现过个问题, 所有的text都是灰色, 然后用以下方法解决的

在style里面添加:
&lt;item name=&quot;android:textViewStyle&quot;&gt;@style/MyTextViewStyle&lt;/item&gt;

&lt;style name=&quot;MyTextViewStyle&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
        &lt;!-- Customize your theme here. --&gt;
        &lt;item name=&quot;android:textColor&quot;&gt;@color/colorBlack&lt;/item&gt;

&lt;/style&gt;
</code></pre>
<br>
<ul>
<li>
<h3 id="imageview">ImageView</h3>
</li>
</ul>
<pre><code class="language-html">tint属性可以将图片整体换颜色，常用在同样形状但是不同颜色的btn上

&lt;ImageView
    android:src=&quot;@drawable/earth&quot; //注意必须是src配置，不能是background
    android:tint=&quot;#F9F900&quot; //假设pic是地球🌍图片，使用tint之后会显示为黄色的圆🌕
/&gt;
</code></pre>
<br>
<ul>
<li>
<h3 id="actionbarsize">ActionBarSize</h3>
</li>
</ul>
<pre><code class="language-html">定制ActionBar高度

style.xml加入
&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
        ...
        &lt;item name=&quot;@android:attr/actionBarSize&quot;&gt;40dp&lt;/item&gt;
    &lt;/style&gt;

注意: 需要miniSDKVersions&gt;11, 或者新建一个valuse-vXX/style.xml, XX&gt;11



获取ActionBar高度
TypedArray actionbarSizeTypedArray = 
                context.obtainStyledAttributes(new int[] {android.R.attr.actionBarSize});
float h = actionbarSizeTypedArray.getDimension(0, 0);
</code></pre>
<br>
<ul>
<li>
<h3 id="color">Color</h3>
</li>
</ul>
<pre><code class="language-html">values新建colors.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;color name=&quot;colorPrimary&quot;&gt;#ae5da1&lt;/color&gt;
&lt;/resources&gt;
</code></pre>
<pre><code class="language-html">引用方式: @color/colorButtonBlue
常见透明度值: (0-&gt;100, 越来越看不见)
0%=FF    5%=F2    10%=E5    15%=D8    20%=CC
25%=BF    30%=B2    35%=A5    40%=99    45%=8c
50%=7F    55%=72    60%=66    65%=59    70%=4c
75%=3F    80%=33    85%=21    90%=19    95%=0c    100%=00

使用方法:加到色值前, 如#FF222222,#59333333
</code></pre>
<br>
<ul>
<li>
<h3 id="shape-自定义形状">Shape 自定义形状</h3>
</li>
</ul>
<pre><code class="language-html">//外部配置
&lt;shape 
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;rectangle | oval | line | ring //矩形、圆形、线、环形
    android:useLevel=&quot;false&quot; //如果当做是LevelListDrawable使用时值为true，否则为false

    //以下2个属性只有当类型为环形时才有效
    android:innerRadius=&quot;10dp&quot; //内环半径
    android:thickness=&quot;10dp&quot;&gt; //环的厚度

    。。。

&lt;/shape&gt;


//内部配置
    &lt;size android:height=&quot;100dp&quot;
          android:width=&quot;100dp&quot;/&gt;

    &lt;!-- 边框宽度及颜色 --&gt;
    &lt;stroke android:width=&quot;1dp&quot;
            android:color=&quot;#FFFFFF&quot;

            //以下2个属性只有当类型为线形时才有效
            android:dashGap=&quot;5dp&quot; //虚线间隔宽度
            android:dashWidth=&quot;5dp&quot;/&gt; //虚线宽度
    
    &lt;!-- 填充颜色 --&gt;
    &lt;solid android:color=&quot;@color/colorPrimary&quot;/&gt;

    &lt;!-- 渐变色·垂直渐变：只能为45的倍数角度 --&gt;
    &lt;gradient android:startColor=&quot;@android:color/white&quot;
              android:endColor=&quot;@android:color/black&quot;
              android:angle=&quot;0&quot;/&gt;
    &lt;!-- 渐变色·中心渐变 --&gt;
    &lt;gradient android:centerX=&quot;0.5&quot; //渐变中心的X轴坐标
              android:centerY=&quot;0.5&quot; //渐变中心的Y轴坐标
              android:type=&quot;sweep | radial&quot; //扫描性渐变、放射渐变（需要设置android:gradientRadius）
              android:startColor=&quot;@android:color/white&quot;
              android:endColor=&quot;@android:color/black&quot;/&gt;

    &lt;padding android:bottom=&quot;10dp&quot;
             android:left=&quot;10dp&quot;
             android:right=&quot;10dp&quot;
             android:top=&quot;10dp&quot;/&gt;
    
    //只用于矩形上设置圆角
    &lt;!-- 设置四个角的弧度 --&gt;
    &lt;corners android:radius=&quot;20dip&quot; /&gt;
    &lt;!-- 或者分别设置四个角的弧度 --&gt;
    &lt;corners
        android:topLeftRadius=&quot;10dp&quot;
        android:topRightRadius=&quot;20dp&quot;
        android:bottomLeftRadius=&quot;50dp&quot;
        android:bottomRightRadius=&quot;100dp&quot;/&gt;
</code></pre>
<br>
<ul>
<li>
<h3 id="vector-svg-自定义圆形">Vector (SVG) 自定义圆形</h3>
</li>
</ul>
<pre><code class="language-html">&lt;path
    android:pathData=&quot;M24 24 A 10 10 0 1 0 24 23.99999&quot; //最后两值不能相同
    android:strokeWidth=&quot;1&quot; //线宽
    android:strokeColor=&quot;@color/colorAccent&quot; //线色
    android:fillColor=&quot;@color/dialog_orange&quot;/&gt;  //填充色,不加属性默认为不填充
 

参数含义:
M 24 24 (起始点)
    
A(代表要画弧)      

10 10 (x, y 轴半径)

0 (x轴旋转角度, 没懂)

1 (0/1-小/大弧度) : 给定一个起终点和半径, 能画出2种弧. 优弧(1)和劣弧(0)

0 (0/1-逆/顺时针)

24  23.999 (弧的起终点不能是同一点, 因为同一点之间无法构成线)
</code></pre>
<br>
<br>
<h2 id="四大组件">四大组件</h2>
<ul>
<li>
<h3 id="自定义广播">自定义广播</h3>
</li>
</ul>
<pre><code class="language-java">sendBroadcast(new Intent(getApplication(),MyBroadcastReceiver.class));

//manifest添加
&lt;receiver android:name=&quot;com.example.demo.MyBroadcastReceiver&quot;/&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://ArsenicX.github.io/Git</id>
        <link href="https://ArsenicX.github.io/Git">
        </link>
        <updated>2020-02-14T05:44:49.000Z</updated>
        <content type="html"><![CDATA[<p>layout: post</p>
<p>title:  &quot;Git 常用命令&quot;</p>
<p>date:   2018-08-17 16:33:03</p>
<p>categories: git_Github<br>
comments: false</p>
<hr>
<h2 id="分支-master-暂存区-stage-工作区-work-dict"><strong>分支: master   暂存区: stage    工作区: work dict</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/04/08/5caabaf1cb2c6.jpg" alt="" loading="lazy"></figure>
<br>
<pre><code>pwd                       当前路径
ls -ah                    当前路径下的所有文件
touch &lt;file&gt;              新建
cat &lt;file&gt;                读取
vi &lt;file&gt;                 linux方式读取 a表示输入 :wq表示保存并退出 :q表示直接退出
git rm &lt;file&gt;             删除



git status                更改过的文件 work dict和master的比较
git diff (file)           具体显示更改内容 work dict和stage的比较,且只能查到修改过的文件,新建文件查不出来
git diff --cached         具体显示更改内容 stage和master的比较



git checkout -- &lt;file&gt;    撤销 work dict被stage覆盖
git reset head &lt;file&gt;     撤销 stage的修改被撤销
git reset --hard head^    撤销 work dict和stage被master几次前的历史内容覆盖几个^就代表几次之前
                              X次前也可以用HEAD~X代替
git reset --hard xxxx     撤销及还原撤销work,dict和stage被master中commit id为xxxx的历史内容覆盖



git log (--pretty=oneline)    显示日志(简要版) 显示的是目前master中存在的历史版本的日志记录,已撤销的查不到
git reflog                    显示日志 显示的是所有操作的日志记录,包括已撤销的
git log --graph               线性图示显示日志
git log xxxx -1               只看xxxxx的日志
git log xxxx -1 -p            查看xxxx具体修改内容



git branch                    当前分支
git checkout -b &lt;T&gt;           新建分支并切换到新分支 等同于git branch &lt;T&gt; + git checkout &lt;T&gt;
git merge &lt;T&gt;                 将当前分支指向T分支 也就是将T分支内容覆盖到当前分支
git merge --abort             取消合并命令 用于合并失败后
git log --graph               可查看分支合并图
git branch -d &lt;T&gt;             删除分支T



git stash                     用于代码临时贮存.如:突然接到命令要修改master代码,但手头分支还没完成不能commit
git stash list                查看临时贮存列表
git stash pop                 恢复并删除stash(等同于git stash apply (stash@{X}) + git stash drop)
                                  X从list命令中查看
                                  注意:新入栈的修改位居栈顶



git tag                                  查看标签
git tag &lt;tagname&gt; (xxxx)                 给当前分支(/xxxx分支)创建标签 和commit对应
git show &lt;tagname&gt;                       查看tagname标签
git push origin &lt;tagname&gt;/--tags         推送tagname标签/所有标签
git tag -d &lt;tagname&gt;                     删除本地标签
git push origin :refs/tags/&lt;tagname&gt;     删除远程标签



git add -f &lt;file&gt;                        强制添加被ignore的文件
git check-ignore -v &lt;file&gt;               查看与file有关的忽略配置
git config (--global) alias.XX status    用git XX代替git status global代表仅当前项目有效(.git/config)
                                             去掉global代表全局设置(cd 初始目录/.gitconfig)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[泛型]]></title>
        <id>https://ArsenicX.github.io/fan-xing</id>
        <link href="https://ArsenicX.github.io/fan-xing">
        </link>
        <updated>2020-02-14T03:46:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么需要泛型">为什么需要泛型</h1>
<p>譬如我们需要一个数组类IntList，它存放int类型，并且有我们自定义的增加、删除、排序功能。<br>
后来我们发现只有一个int类型的数组不够，我们还需要一个有同样功能的数组类StringList，那么这时候就要再new一个class文件，这就十分繁琐了<br>
泛型就是解决这个问题的。它在定义时可以告诉编译器：我不把其中的参数类型写死，它可以是int、String等等，这个由我以后使用的时候决定</p>
<h1 id="泛型怎么使用">泛型怎么使用</h1>
<h2 id="在定义的时候">在定义的时候</h2>
<p>如果当前的类有可能会需要用到多种数据类型，那这个时候就要在class上注明&lt;T&gt;。例如：</p>
<pre><code class="language-java">public class MyList&lt;T&gt;{ 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public MyList(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }

    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}
</code></pre>
<h2 id="在使用的时候">在使用的时候</h2>
<ol>
<li>创建泛型类对象：泛型写实际使用的参数<code>MyList&lt;String&gt; myList = new MyList&lt;String&gt;(&quot;字符串&quot;);</code></li>
<li>使用泛型类对象作为参数：<br>
如果能确定将接收到的泛型类的参数，就直接指定好：<code>public void showKeyValue(MyList&lt;String&gt; myList){...}</code><br>
如果不确定，就写作&lt;?&gt;：<code>public void showKeyValue(MyList&lt;?&gt; myList){...}</code></li>
</ol>
<h1 id="上下界">上下界</h1>
<ul>
<li>extends和super都不能在泛型类<strong>定义</strong>时使用</li>
<li>super只能在<strong>使用泛型类对象作为参数</strong>时使用，不能用于<strong>创建泛型类对象</strong>；extends无限制</li>
</ul>
<h1 id="限制">限制</h1>
<p>详见：<a href="https://blog.csdn.net/hanchao5272/article/details/79352321">泛型使用的8个限制</a></p>
]]></content>
    </entry>
</feed>