<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ArsenicX.github.io/</id>
    <title>ArsenicX</title>
    <updated>2020-03-27T03:01:18.495Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ArsenicX.github.io/"/>
    <link rel="self" href="https://ArsenicX.github.io/atom.xml"/>
    <logo>https://ArsenicX.github.io/images/avatar.png</logo>
    <icon>https://ArsenicX.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ArsenicX</rights>
    <entry>
        <title type="html"><![CDATA[计算机网络]]></title>
        <id>https://ArsenicX.github.io/ji-suan-ji-wang-luo/</id>
        <link href="https://ArsenicX.github.io/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-03-27T01:30:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-概述">一.  概述</h1>
<h2 id="一-计算机网络的性能指标">一. 计算机网络的性能指标：</h2>
<ol>
<li>
<p>速率（车速）<br>
在表示速度速率时，1M=10<sup>6</sup></p>
</li>
<li>
<p>带宽（路宽）<br>
在表示带宽或者存储时，1M=2<sup>20</sup></p>
</li>
<li>
<p>吞吐量：在单位时间内<strong>实际</strong>通过某个网络的数据量，单位是b/s, Mb/s。</p>
</li>
<li>
<p>时延<br>
对于高速网络链路，我们提高的仅仅是数据的<strong>发送速率</strong>而不是比特在链路上的<strong>传播速率</strong>。传播速率取决于通信线路的材料<br>
通常我们所说的“光纤速度更快”，说的其实是光纤可以以更高的速度向光纤信道<strong>发送数据</strong>，而不是指信号在光纤中<strong>传播速度</strong>要比在铜线中快。实际上，光在光纤中的传播速度（20.5万公里/秒）确实要比电磁波在铜线中的传播速度（23.1万公里/秒）要低一些</p>
</li>
<li>
<p>时延X带宽(时延带宽积)：有多少数据正在线路上。<br>
<img src="https://github.com/ArsenicX/image-host/blob/master/%E6%89%B9%E6%B3%A8%202020-03-27%20094255.png?raw=true" alt="" loading="lazy"></p>
</li>
<li>
<p>利用率<br>
要注意，信道利用率并非越高越好，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加；可以类比于公路上车辆越多，公路的利用率就越高，但是不可避免地就会造成堵车。<br>
网络当前时延D = 网络空闲时的时延D<sub>0</sub> / (1 - 信道利用率U)<br>
因此，对于一些较大的主干网的ISP，他们通常会将利用率控制在50%以下。</p>
</li>
</ol>
<h2 id="二-通信协议">二. 通信协议：</h2>
<h3 id="1-osi参考模型">1. OSI参考模型：</h3>
<ul>
<li>应用层——所有能产生网络流量的程序</li>
<li>表示层——在传输之前是否进行加密 或 压缩 处理，二进制或ASCII码表示</li>
<li>会话层——查木马，看需求端和网站之间的连接</li>
<li>传输层——可靠传输，流量控制，不可靠传输(一个数据包即可，不需要建立会话，例如向DNS查询网站IP地址)</li>
<li>网络层——负责选择最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)</li>
<li>数据链路层——帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)</li>
<li>物理层——定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快</li>
</ul>
<ol>
<li>
<p>OSI参考模型对网络排错的意义：每一层都为上一层提供服务，一旦某一层崩了，上面所有层都崩了，所以排查问题从最底层(物理层)排查；</p>
<ol>
<li>物理层故障怎么办？<br>
查看链接状态，发送和接收的数据包数值；</li>
<li>数据链路层故障怎么办？<br>
Mac地址冲突，2个一样的Mac地址同时访问；ADSL(非对称数字用户线路)欠费；两端的接口网速没有协商一致；计算机连接到其它VLAN(虚拟互联网)中。</li>
<li>网络层故障怎么办？<br>
配置错误的IP地址，子网掩码，网关；数据有没有通过各个网关到达指定位置；</li>
<li>应用层(合并3层)故障怎么办？<br>
应用程序配置问题</li>
</ol>
</li>
<li>
<p>OSI参考模型和网络安全解决办法：</p>
<ol>
<li>物理层安全隐患？<br>
别人能私自接入你的网络，应该拔掉不用的网线或接口；</li>
<li>数据链路层安全隐患？<br>
ADSL账号密码，VLAN，交换机端口绑定Mac地址</li>
<li>网络层安全隐患？<br>
路由器上使用ACL(访问控制列表)控制数据包流量；防火墙设置；</li>
<li>应用层安全隐患？<br>
应用程序有没有漏洞</li>
</ol>
</li>
</ol>
<h3 id="2-5层协议数据传递图">2. 5层协议数据传递图</h3>
<figure data-type="image" tabindex="1"><img src="https://github.com/ArsenicX/image-host/blob/master/%E6%89%B9%E6%B3%A8%202020-03-27%20102039.png?raw=true" alt="" loading="lazy"></figure>
<h3 id="3-当今">3. 当今</h3>
<p><img src="https://ArsenicX.github.io//post-images/1585278031861.png" alt="" loading="lazy"><br>
现如今，技术的发展并不是遵循严格的 OSI 分层概念。实际上现在的互联网使用的 TCP/IP 体系结构有时已经演变成为下图所示那样<br>
<img src="https://github.com/ArsenicX/image-host/blob/master/5183824-d30d533385a087d6.png?raw=true" alt="" loading="lazy"><br>
<img src="https://github.com/ArsenicX/image-host/blob/master/5183824-e261fc9c3a2170ed.png?raw=true" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Regular expression]]></title>
        <id>https://ArsenicX.github.io/regular-expression/</id>
        <link href="https://ArsenicX.github.io/regular-expression/">
        </link>
        <updated>2020-03-25T05:01:25.000Z</updated>
        <content type="html"><![CDATA[<p>https://youtube.com/user/fengnz/videos</p>
<p>元字符		<br>
任意1个字符	.	<br>
字母数字+下划线	\w	<br>
数字	\d	<br>
空白字符	\s	空格、tab、换行</p>
<p>锚点		<br>
边界	\b	用于单词<br>
^	^Ha表示以Ha开头的句子。注意是句子，而不是词组<br>
在[]中，<sup>表示非。[</sup>a-z]表示不是a-z的任意字符<br>
$	Ha$表示以Ha结尾的句子。注意是句子，而不是词组</p>
<p>重复		<br>
出现0次或者一次	?	?前面的字符可以出现0次或者1次<br>
出现0次或者多次	*	*前面的字符可以出现0次或者多次<br>
出现一次或者多次	+	+前面的字符可以出现一次或者多次<br>
出现a次到b次	{a,b}	{}前面的字符可以出现a次到b次</p>
<p>贪婪模式	*	尽可能多地匹配相符内容<br>
懒惰模式	*?	尽可能少地匹配相符内容<br>
侵占模式	*+	尽可能多地匹配相符内容, 绝不留给其他部分使用</p>
<p>组		<br>
字符集	[]	注意：这是一个字符<br>
[ab4.7*/f] 表示匹配“ab4.7*/f”中的任意一个<br>
[A-z3-87] 中的“-”是范围，表示匹配从大写A到小写z或从3到87中的任何一个 （A=65，z=122，有大小顺序之分）<br>
分组	()	M(a|b|ab) 表示匹配Ma、Mb和Mab<br>
$1、$2...可以用来代替原文中匹配到的组<br>
在()中加入“?:”，表示不设为分组，例：&quot;(?:a)(b)&quot; 此时$1就是&quot;b&quot;<br>
前瞻	(?=)	检查全部字符串中是否包括所需字符<br>
(?=a1).<em>b2: 表示先检查整段字符串中是否含有a1，如果含有，就</em>a1的位置*开始匹配剩下的东西（即&quot;.*b2&quot;）;若没有，则匹配失败</p>
<p>替换		<br>
自己	\0</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂]]></title>
        <id>https://ArsenicX.github.io/other/</id>
        <link href="https://ArsenicX.github.io/other/">
        </link>
        <updated>2020-03-25T05:00:42.000Z</updated>
        <content type="html"><![CDATA[<p>五大常用算法：https://blog.csdn.net/ling_wang/article/details/81560925<br>
在Mac上完全删除android studio初始配置文件：https://blog.csdn.net/qq_21996633/article/details/51079380</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Data Structure]]></title>
        <id>https://ArsenicX.github.io/data-structure/</id>
        <link href="https://ArsenicX.github.io/data-structure/">
        </link>
        <updated>2020-03-25T04:58:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="小技巧">小技巧</h3>
<ul>
<li>怎么获得1-100的随机数：系统自带的随机数函数会返回一个未知位数的随机数，可以把这个数对100取余</li>
</ul>
<h2 id="总结">总结：</h2>
<p>1.<code>float</code>和<code>double</code><br>
<code>scanf(&quot;%lf&quot;) printf(&quot;%f&quot;)</code> 注意一个是<code>lf</code>，一个是<code>f</code></p>
<ol start="2">
<li>
<p>运算符优先级：单目 &gt; 算术(加减乘除) &gt; 关系(==、&gt;=...) &gt; 赋值<br>
单目运算符，比如<code>a*-b</code>：表示的是先对b取相反数，然后再与a相乘。单目优先级最高<br>
多个关系运算符中，==和!=最低。例如：<code>5&gt;3==6&gt;4</code>表示的是<code>(5&gt;3)==(6&gt;4)</code>，最后返回的是1</p>
</li>
<li>
<p><code>switch-case</code><br>
虽然样子和功能看上去类似<code>if else</code>嵌套<br>
但是用debug断点就可以看到，<code>if else</code>是从第一条if开始，一个一个向下判断是否匹配，费时费力；而<code>switch-case</code>是直接跳到对应的<code>case</code>语句<br>
这样带来的好处就是，<code>switch-case</code>的效率不会被候选匹配项的数量影响</p>
</li>
</ol>
<blockquote>
<p>常见用法：成绩评定级别（90分以上为A，80-89为B...）</p>
<pre><code class="language-java">switch（score/10）{
case 10:
case 9: printf(&quot;A&quot;);
...}
</code></pre>
</blockquote>
<ol start="4">
<li></li>
<li></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开发者指南 - 学习笔记]]></title>
        <id>https://ArsenicX.github.io/android-kai-fa-zhe-zhi-nan-xue-xi-bi-ji/</id>
        <link href="https://ArsenicX.github.io/android-kai-fa-zhe-zhi-nan-xue-xi-bi-ji/">
        </link>
        <updated>2020-03-25T04:55:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="官网地址"><a href="https://developer.android.google.cn/guide">官网地址</a></h1>
<h1 id="第一部分-app-basics">第一部分 App Basics：</h1>
<h1 id="入门">入门</h1>
<ul>
<li>
<p>在Design标签下，点击Button图标，会出现一个Edit Baseline<img src="https://developer.android.google.cn/studio/images/buttons/layout-editor-action-baseline.png" alt="" loading="lazy">按钮（它将显示在设计编辑器中选定视图的正下方），它可以用来和其他组件居中对齐。如下图：<br><img src="https://developer.android.google.cn/training/basics/firstapp/images/constraint-button_2x.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>Intent</strong>：intent.putExtra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在您的应用与其他应用交互时这些键始终保持唯一</p>
<pre><code class="language-java">public static final String EXTRA_MESSAGE = &quot;com.example.myfirstapp.MESSAGE&quot;;
intent.putExtra(EXTRA_MESSAGE, message);
</code></pre>
</li>
<li>
<p><strong><a href="https://developer.android.google.cn/guide/components/fundamentals">应用可以通过一些途径与其他应用共享数据以及访问系统服务</a></strong></p>
<ol>
<li>可以安排两个应用共享同一 Linux 用户 ID，在这种情况下，它们能够相互访问彼此的文件。 为了节省系统资源，可以安排具有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM（应用还必须使用相同的证书签署）</li>
</ol>
</li>
</ul>
<h1 id="资源文件-resources">资源文件 Resources</h1>
<h2 id="res资源目录及限定符"><code>res/</code>资源目录及限定符</h2>
<h3 id="res目录内支持的资源目录"><code>res/</code>目录内支持的资源目录</h3>
<table>
<thead>
<tr>
<th>目录</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>animator/</td>
<td>用于定义<a href="https://developer.android.google.cn/guide/topics/graphics/prop-animation.html">属性动画</a>的 XML 文件。</td>
</tr>
<tr>
<td>anim/</td>
<td>定义<a href="https://developer.android.google.cn/guide/topics/graphics/view-animation.html#tween-animation">渐变动画</a>的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 <code>animator/</code> 目录。）</td>
</tr>
<tr>
<td>color/</td>
<td>用于定义颜色状态列表的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/color-list-resource.html">颜色状态列表资源</a></td>
</tr>
<tr>
<td>drawable/</td>
<td>位图文件（<code>.png</code>、<code>.9.png</code>、<code>.jpg</code>、<code>.gif</code>）或编译为以下可绘制对象资源子类型的 XML 文件：<br> 1.  位图文件<br> 2.  九宫格（可调整大小的位图）<br> 3.  状态列表<br> 4.  形状<br> 5.  动画可绘制对象<br> 6.  其他可绘制对象<br>  <br>请参阅 <a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource.html">可绘制对象资源</a>。</td>
</tr>
<tr>
<td>mipmap/</td>
<td>适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 <code>mipmap/</code> 文件夹管理启动器图标的详细信息，请参阅<a href="https://developer.android.google.cn/tools/projects/index.html#mipmap">管理项目概览</a>。</td>
</tr>
<tr>
<td>layout/</td>
<td>用于定义用户界面布局的 XML 文件。 请参阅<a href="https://developer.android.google.cn/guide/topics/resources/layout-resource.html">布局资源</a>。</td>
</tr>
<tr>
<td>menu/</td>
<td>用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/menu-resource.html">菜单资源</a>。</td>
</tr>
<tr>
<td>raw/</td>
<td>要以原始形式保存的任意文件。要使用原始 <code>InputStream</code> 打开这些资源，请使用资源 ID（即 <code>R.raw.filename</code>）调用 <code>Resources.openRawResource()</code>。<br>但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 <code>assets/</code> 目录下（而不是 <code>res/raw/</code>）。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 <code>AssetManager</code> 读取这些文件。</td>
</tr>
<tr>
<td>values/</td>
<td>包含字符串、整型数和颜色等简单值的 XML 文件。<br><br/>其他 <code>res/</code> 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均定义一个资源。例如，<code>&lt;string&gt;</code> 元素创建 <code>R.string</code> 资源，<code>&lt;color&gt;</code> 元素创建 <code>R.color</code> 资源。<br><br>由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：<br> 1.  arrays.xml，用于资源数组（<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#TypedArray">类型化数组</a>）。<br> 2.  colors.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Color">颜色值</a>。<br> 3.  dimens.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Dimension">尺寸值</a>。<br> 4.  strings.xml：<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html">字符串值</a>。<br> 5.  styles.xml：<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html">样式</a><br>请参阅<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html">字符串资源</a>、<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html">样式资源</a>和<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html">更多资源类型</a>。</td>
</tr>
<tr>
<td>xml/</td>
<td>可以在运行时通过调用 <code>Resources.getXML()</code> 读取的任意 XML 文件。各种 XML 配置文件（如<a href="https://developer.android.google.cn/guide/topics/search/searchable-config.html">可搜索配置</a>）都必须保存在此处。</td>
</tr>
</tbody>
</table>
<h3 id="资源限定符"><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#table2">资源限定符</a></h3>
<table>
<thead>
<tr>
<th>配置</th>
<th>限定符值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>语言和区域</td>
<td>示例：<br/><code>en</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>fr</code><br>
<code>en-rUS</code><br>
<code>fr-rFR</code><br>
<code>fr-rCA</code><br>
等等    | 语言通过由两个字母组成的 <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO 639-1</a> 语言代码定义，可以选择后跟两个字母组成的 <a href="https://www.iso.org/obp/ui/#iso:pub:PUB500001:en">ISO 3166-1-alpha-2</a> 区域码（前带小写字母“<code>r</code>”）。 |<br>
| smallestWidth | sw<N>dp<br>示例：<br><code>sw320dp</code> <code>sw600dp</code> <code>sw720dp</code> | 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 <code>&lt;N&gt;</code>dp。 |<br>
| 屏幕尺寸      | small<code></code>normal<code></code>large<code></code>xlarge                    | <code>small</code>：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。<br/> <code>normal</code>：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。 <br/><code>large</code>：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。<br/> <code>xlarge</code>：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。<em>API 级别 9 中的新增配置。</em> |<br>
| ...           | ...                                                | ...                                                          |<br>
<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#BestMatch"><strong>系统对于不同资源限定符的选择算法</strong></a><br> 1. 淘汰掉和设备冲突的资源文件。比如设备如果是英文<code>en</code>的，就会先直接排除掉<code>fr</code>、<code>cn</code>等限定符的资源<br> 2. 依照<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#table2">此表</a><strong>从上到下</strong>寻找有没有匹配的。即先找有没有<em>移动国家代码 <code>MCC/MNC</code></em> 限定的资源，有的话直接排除其他；反之寻找有没有<em>语言和区域</em> 限定的资源。<br> 3. 重复第2步，从二级目录开始依次淘汰，只到剩下只有一个资源目录。比如现在已经通过<em>语言和区域</em> 排除过后依旧剩下了3个资源目录，则再看语言限定符之后，有无<em>布局方向</em> 限定符，有的话排除其他；反之寻找有没有<em>屏幕基本尺寸 <code>smallestWidth</code></em>，只到剩下最后一个资源文件夹。<br><br>	<strong>注意⚠️：<em>屏幕像素密度 <code>dpi</code></em> 为特例，不能淘汰</strong> <br>		如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html">支持多种屏幕</a>。<br>		根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统<strong>不会</strong>使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。<br><br>举个栗子🌰：</p>
<blockquote>
<p>假设目前有以下资源目录：</p>
<pre><code>drawable/
drawable-en/
drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</code></pre>
<p>且设备的配置如下：</p>
<p>​	语言区域 = <code>en-GB</code><br>
​	屏幕方向 = <code>port</code><br>
​	屏幕像素密度 = <code>hdpi</code><br>
​	触摸屏类型 = <code>notouch</code><br>
​	主要文本输入法 = <code>12key</code></p>
<p><br>首先，可以排除<code>drawable-fr-rCA/</code> 因为和设备配置冲突</p>
<pre><code class="language-java">drawable/
drawable-en/
// drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</code></pre>
<p>其次，因为目前目录中有语言限定符，且符合设备，所以可以继续排除非<code>en</code>开头的限定符</p>
<pre><code class="language-java">// drawable/
drawable-en/
drawable-en-port/
drawable-en-notouch-12key/
// drawable-port-ldpi/
// drawable-port-notouch-12key/
</code></pre>
<p>筛选过后还剩下不止一个资源，所以重复第二步方法筛选。因为<code>port</code>优先级比<code>notouch</code>高，所以排除<code>notouch</code></p>
<pre><code class="language-java">// drawable-en/
drawable-en-port/
// drawable-en-notouch-12key/
</code></pre>
<p>最后得到唯一的资源目录。之后在程序请求资源时都将会在该目录下找</p>
</blockquote>
<h2 id="运行时变更配置如何处理">运行时变更配置如何处理</h2>
<p>A. 在配置变更期间保留对象：<br>	通常我们可以依靠系统通过<code>onSaveInstanceState()</code> 回调保存的 <code>Bundle</code>， 但是它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。所以当重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作时，此时建议通过保留<code>Fragment</code>来减轻重新初始化 Activity 的负担，可以在 <code>Fragment</code>中包含要保留的有状态对象的<strong>引用</strong>。<br><br>要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：</p>
<p>​	1. 扩展 <code>Fragment</code> 类并声明对有状态对象的引用。</p>
<p>​	2. 在创建片段后调用 <code>setRetainInstance(boolean)</code>。</p>
<p>​	3. 将片段添加到 Activity。</p>
<p>​	4. 重启 Activity 后，使用 <code>FragmentManager</code> 检索片段。<br>例如：</p>
<pre><code class="language-java">public class RetainedFragment extends Fragment {

    // data object we want to retain
    private MyDataObject data;

    // this method is only called once for this fragment
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // retain this fragment
        setRetainInstance(true);
    }

    public void setData(MyDataObject data) {
        this.data = data;
    }

    public MyDataObject getData() {
        return data;
    }
}
</code></pre>
<blockquote>
<p>**注意⚠️：**尽管可以存储任何对象，但是切勿传递与 <code>Activity</code> 绑定的对象，例如，<code>Drawable</code>、<code>Adapter</code>、<code>View</code> 或其他任何与 <code>Context</code> 关联的对象。以免内存泄漏。</p>
</blockquote>
<p>然后，使用 <code>FragmentManager</code> 将片段添加到<code>Activity</code>。在运行时配置变更期间再次启动<code>Activity</code>时，您可以获得片段中的数据对象。 例如，按如下方式定义<code>Activity</code>：</p>
<pre><code class="language-java">public class MyActivity extends Activity {

    private RetainedFragment retainedFragment;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // find the retained fragment on activity restarts
        FragmentManager fm = getFragmentManager();
        retainedFragment = (RetainedFragment) fm.findFragmentByTag(“data”);

        // create the fragment and data the first time
        if (retainedFragment == null) {
            // add the fragment
            retainedFragment = new RetainedFragment();
            fm.beginTransaction().add(retainedFragment, “data”).commit();
            // load the data from the web
            retainedFragment.setData(loadMyData());
        }

        // the data is available in retainedFragment.getData()
        ...
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // store the data in the fragment
        retainedFragment.setData(collectMyLoadedData());
    }

</code></pre>
<p>在此示例中，<code>onCreate()</code> 添加了一个片段或恢复了对它的引用。此外，<code>onCreate()</code> 还将有状态的对象存储在片段实例内部。<code>onDestroy()</code> 对所保留的片段实例内的有状态对象进行更新。</p>
<p><br><br>B. 自行处理配置变更：<br>	如果应用在配置改变时无需更新资源，并且如果因性能限制需要尽量避免重启，则可声明 <code>Activity</code> 将自行处理配置变更，这样可以阻止系统重启 <code>Activity</code>。<br></p>
<blockquote>
<p>​	自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在您<strong>必须</strong>避免 Activity 因配置变更而重启这一<strong>万般无奈</strong>的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并<strong>不建议</strong>使用此方法。</p>
</blockquote>
<p>如果要声明由 <code>Activity</code> 处理配置变更，在清单文件中添加<code>android:configChanges</code>元素即可。在其<a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config">属性文档</a>中列出了可以添加的属性值。</p>
<pre><code class="language-html">&lt;activity android:name=&quot;.MyActivity&quot;
          android:configChanges=&quot;orientation|keyboardHidden&quot;
          android:label=&quot;@string/app_name&quot;&gt;
</code></pre>
<p>现在，当其中一个配置发生变化时，<code>MyActivity</code> 便不会重启。相反，<code>MyActivity</code> 会收到对 <code>onConfigurationChanged()</code> 的调用。向此方法传递 <code>Configuration</code> 对象指定新设备配置。您可以通过读取<code>Configuration</code> 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的<code>Resources</code> 对象会相应地进行更新，以根据新配置返回资源，这样，您就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。</p>
<blockquote>
<p><strong>注意：<strong>从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，</strong>“屏幕尺寸”也会发生变化</strong>。因此，在开发针对 API 级别 13 或更高版本（正如 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min"><code>minSdkVersion</code></a> 和 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target"><code>targetSdkVersion</code></a> 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 <code>&quot;orientation&quot;</code> 值以外，您还必须添加 <code>&quot;screenSize&quot;</code> 值。</p>
</blockquote>
<p>例如，以下 <code>onConfigurationChanged()</code> 实现检查当前设备方向：</p>
<pre><code class="language-java">@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    // Checks the orientation of the screen
    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show();
    } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){
        Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre>
<blockquote>
<p>​	在声明由 Activity 处理配置变更时，您有责任重置要为其提供备用资源的所有元素。 如果您声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 <code>onConfigurationChanged()</code> 期间将每个资源重新分配给每个元素。</p>
<p>​	如果无需基于这些配置变更更新应用，则可不用实现 <code>onConfigurationChanged()</code>。在这种情况下，仍将使用在配置变更之前用到的所有资源。</p>
</blockquote>
<p>如需了解有关可以在 Activity 中处理哪些配置变更的详细信息，请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config"><code>android:configChanges</code></a> 文档和 <a href="https://developer.android.google.cn/reference/android/content/res/Configuration.html"><code>Configuration</code></a>类。</p>
<h2 id="本地化-eng"><a href="https://developer.android.google.cn/guide/topics/resources/localization">本地化 Eng</a></h2>
<h2 id="复合xml-资源-eng"><a href="https://developer.android.google.cn/guide/topics/resources/complex-xml-resources">复合XML 资源 Eng</a></h2>
<h2 id="资源类型详解-eng"><a href="https://developer.android.google.cn/guide/topics/resources/available-resources">资源类型详解 Eng</a></h2>
<h1 id="应用清单-manifest">应用清单 manifest</h1>
<h2 id="应用清单">应用清单</h2>
<p>​	<code>android:label</code>用来指定<code>app</code>名称或<code>activity</code>名称。因为<code>activity</code>比<code>application</code>更具体，所以会优先使用<code>activity</code>中的<code>android:label</code>。</p>
<h2 id="清单文件结构及详解"><a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro#filestruct">清单文件结构及详解</a></h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;manifest&gt;

    &lt;uses-permission /&gt;
    &lt;permission /&gt;
    &lt;permission-tree /&gt;
    &lt;permission-group /&gt;
    &lt;instrumentation /&gt;
    &lt;uses-sdk /&gt;
    &lt;uses-configuration /&gt;  
    &lt;uses-feature /&gt;  
    &lt;supports-screens /&gt;  
    &lt;compatible-screens /&gt;  
    &lt;supports-gl-texture /&gt;  

    &lt;application&gt;

        &lt;activity&gt;
            &lt;intent-filter&gt;
                &lt;action /&gt;
                &lt;category /&gt;
                &lt;data /&gt;
            &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/activity&gt;

        &lt;activity-alias&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/activity-alias&gt;

        &lt;service&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data/&gt;
        &lt;/service&gt;

        &lt;receiver&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/receiver&gt;

        &lt;provider&gt;
            &lt;grant-uri-permission /&gt;
            &lt;meta-data /&gt;
            &lt;path-permission /&gt;
        &lt;/provider&gt;

        &lt;uses-library /&gt;

    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
<h2 id="文件约定规则">文件约定规则</h2>
<ul>
<li>元素：
<ul>
<li>只有 <code>&lt;manifest&gt;</code> 和 <code>&lt;application&gt;</code> 元素是必需的，它们都必须存在并且只能出现一次。</li>
<li>同一级别的元素通常不分先后顺序。例如，<code>&lt;activity&gt;</code>、<code>&lt;provider&gt;</code> 和 <code>&lt;service&gt;</code> 元素可以按任何顺序混合在一起。但这条规则有两个主要例外：
<ul>
<li><code>&lt;activity-alias&gt;</code> 元素必须跟在别名所指的 <code>&lt;activity&gt;</code> 之后。</li>
<li><code>&lt;application&gt;</code> 元素必须是 <code>&lt;manifest&gt;</code> 元素内最后一个元素。换言之，<code>&lt;/manifest&gt;</code> 结束标记必须紧接在 <code>&lt;/application&gt;</code> 结束标记后。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="权限-permission"><a href="https://developer.android.google.cn/guide/topics/permissions/overview">权限 Permission</a></h1>
<h2 id="概述-eng">概述 Eng</h2>
<ul>
<li>
<p>对于硬件设备的需求的权限声明</p>
<p>​	在调用设备硬件（比如蓝牙或相机）时，需要用户的授权才能使用。但是，并不是所有的设备都有这些硬件，所以别忘了在用户清单中添加<code>&lt;uses-feature&gt;</code>（<code>&lt;uses-feature&gt;</code>说明可见「设备 Device - 应用兼容性概述 Device compatibility overview - 设备特征（Feature ID）」）<br>	如果你声明了<code>android:required=&quot;false&quot;</code>，则 Google Play 会允许没有该硬件的设备安装。而你要在运行时使用 <code>PackageManager.hasSystemFeature()</code>检测设备是否具有某项硬件，如果没有，记得停用使用该硬件的功能。</p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#permission_enforcement">权限的其他功用 Eng</a></p>
<p>​	权限并不只是为了去调用设备的功能，我们也可以自定义权限来自定义限制。</p>
<ol>
<li>Activity 权限限制</li>
</ol>
<p>​	 在<code>&lt;activity&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以跳转该 Activity。<br>	这个权限会在``Context.startActivity()<code>和</code>Activity.startActivityForResult()<code>期间检查，若没有权限的话则调用者会抛出</code>SecurityException`异常。</p>
<ol start="2">
<li>Service 权限限制</li>
</ol>
<p>​	在<code>&lt;service&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以启用或绑定该 Service。<br>	这个权限会在<code>Context.startService()</code>，<code>Context.stopService()</code>和<code>Context.bindService()</code>过程中检查，若没有权限的话则调用者会抛出<code>SecurityException</code>异常。</p>
<ol start="3">
<li>Broadcast 权限限制</li>
</ol>
<p>​	在<code>&lt;receiver&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以向已连接的 BroadcastReceiver发送广播。<br>	因为系统会尝试将广播传递给给定的接受者，所以这个权限会在<code>Context.sendBroadcast()</code>返回后检查；同理，若没有权限的话也不会抛出异常，他只是没有传递出去那个 Intent。</p>
<p>​	同样，也可以给<code>Context.registerReceiver()</code>提供权限去控制 <a href="https://developer.android.google.cn/guide/topics/permissions/overview#broadcast_permission_enforcement">who can broadcast to a programmatically registered receiver. </a>。这种情况下，权限会在调用<code>Context.sendBroadcast()</code>时检查，以去限制哪种广播接收器被允许去接受广播。</p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#auto-adjustments">自动修正权限 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#normal-dangerous">保护等级 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#normal-dangerous">权限组 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#viewing">查看应用涉及到的权限 Eng</a></p>
</li>
</ul>
<h2 id="使用权限的最佳做法">使用权限的最佳做法</h2>
<h3 id="避免请求不必要的权限">避免请求不必要的权限</h3>
<p>本部分提供了常见的替代方法：</p>
<ol>
<li>改用 Intent<br>	要让应用执行某项任务，有两种方法可以选择。应用可以要求提供权限来自行执行该任务，也可以使用 intent 让其他应用执行该任务。<br>	例如，当我们需要使用摄像头拍照时，可以请求<code>CAMERA</code>权限以便应用直接访问摄像头，也可以使用 Intent 来调用其他支持拍照的应用，这样的话就无需请求<code>CAMERA</code>权限了。比如可以使用 Intent 操作类型 <code>MediaStore.ACTION_IMAGE_CAPTURE</code> 或 <code>MediaStore.ACTION_VIDEO_CAPTURE</code> 来拍摄图像或视频。</li>
</ol>
<pre><code>​	&lt;br&gt;如果使用权限：

- 当您执行操作时，您的应用可以完全控制用户体验。不过，这样需要自行创建对应的界面，会增加代码的复杂性。
- 系统会在运行时或安装时（具体取决于用户的 Android 版本）提示用户授予权限一次。如果用户未授予权限（或之后撤消权限），则应用将根本无法执行操作。

如果使用 intent：

- 您不必为操作设计界面。利用 Intent 而调用的应用将提供界面。
- 用户可以使用他们首选的应用执行任务。例如，用户可以选择用他们喜爱的照片应用拍照。
- 如果用户没有适用于操作的默认应用，则系统会提示用户选择一款应用。如果用户未指定默认处理程序，则他们每次执行此操作时都可能必须处理一个额外的对话框。
</code></pre>
<ol start="2">
<li>
<p>不要让用户感到无所适从</p>
<p>​	如果用户运行的是 Android 6.0（API 级别 23）或更高版本，则用户必须在运行应用时为其授予权限。如果您让用户一次面对大量的权限请求，可能会让用户感到无所适从。<br>	合理的做法是，在用户第一次打开应用时就立即请求所有<strong>必要</strong>的权限。比如您的应用是摄影应用，那在用户首次打开应用的时候被要求授权摄像头权限的时候，用户就不会感到不妥；但是，如果同一应用还具有与联系人分享照片的功能，那就建议不要在首次启动时请求授权<code>READ_CONTACT</code>权限，而是应该在用户进行「分享」操作时再请求。<br>	当然，如果应用提供教程，也可以在教程过后请求提供权限。</p>
</li>
<li>
<p>失去音频焦点后暂停媒体</p>
<p>​	有这样一种使用场景，当用户接电话时，应用需要转入后台并且将其媒体播放器暂停或静音。通常的做法是使用 <code>PhoneStateListener</code> 或监听 <code>android.intent.action.PHONE_STATE</code> 的广播，以监听通话状态有无变化。<br>	可是这种解决方法需要请求 <code>READ_PHONE_STATE</code> 权限，而这个权限将会同时得到用户广泛的敏感数据（比如用户的设备和 SIM 硬件 ID 以及来电的电话号码）</p>
<p>​	这时就可以用另一种方式来解决。您可以通过为应用请求 <code>AudioFocus</code>，在没有 <code>READ_PHONE_STATE</code> 或 <code>MODIFY_PHONE_STATE</code> 权限的情况下检测用户是否在通话中。只需将对音频放入后台所需的代码放入<code>onAudioFocusChange()</code> 事件处理程序，当操作系统转换其音频焦点时，它将自动运行。要详细了解如何执行此操作，请参阅<a href="https://developer.android.google.cn/training/managing-audio/audio-focus.html">此文档</a></p>
</li>
<li>
<p>确定正在运行实例的设备</p>
<p>​	在这种情况下，您需要一个唯一标识符来确定您的应用实例正在哪个设备上运行。<br>	应用可能具有设备特定的偏好设置或消息（例如，在云端为用户保存设备特定的播放列表，以便他们在车上和家里可以有不同的播放列表）。常见的解决方案是利用设备标识符（如 <code>Device IMEI</code>），但这需要 <code>Device ID and call information</code> 权限组（M+ 中为 <code>PHONE</code>）。它还使用一个无法重置且在所有应用之间共享的标识符。<br>	下面两种方法可以替代这些类型的标识符：</p>
<ol>
<li>使用 <code>com.google.android.gms.iid</code> InstanceID API。<code>getInstance(Context context).getID()</code> 将为您的应用实例返回一个唯一设备标识符。结果是一个应用实例作用域标识符，在存储有关应用的信息时，该标识符可用作键，如果用户重新安装应用，该标识符会重置。</li>
<li>使用 <a href="https://developer.android.google.cn/reference/java/util/UUID.html#randomUUID()"><code>randomUUID()</code></a> 之类的基本系统函数创建您自己的标识符，其作用域限定为应用的存</li>
</ol>
</li>
<li>
<p>为广告或用户分析创建唯一标识符</p>
<p>​	在这种情况下，您需要一个唯一标识符来为没有登录您应用的用户构建配置文件（例如，用于广告定位或衡量转化率）。<br>	为广告和用户分析构建配置文件有时需要一个在其他应用之间共享的标识符。此问题的常见解决方案需要利用设备标识符（如 <code>Device IMEI</code>），这需要 <code>Device ID</code> <code>and call information</code> 权限组（API 级别 23+ 中为 <code>PHONE</code>），并且无法由用户重置。无论是上述哪种情况，除了使用不可重置的标识符并请求用户可能认为不寻常的权限外，还会违反 <a href="https://play.google.com/about/developer-content-policy.html">Play 开发者计划政策</a>。<br>	遗憾的是，在这些情况下，使用 <code>com.google.android.gms.iid</code> InstanceID API 或系统函数创建应用作用域 ID 并不是适当的解决方案，因为可能需要在应用之间共享该 ID。一种替代解决方案是使用通过 <code>getId()</code> 方法从<code>AdvertisingIdClient.Info</code> 类中获取的 <code>Advertising Identifier</code>。您可以使用 <code>getAdvertisingIdInfo(Context)</code> 方法创建一个 <code>AdvertisingIdClient.Info</code> 对象，并调用 <code>getId()</code> 方法来使用该标识符。<em><strong>请注意，此方法会产生阻塞</strong></em>，因此，您不应从主线程调用它；有关此方法的详细说明，请点击<a href="https://developer.android.google.cn/google/play-services/id.html">此处</a>。</p>
</li>
</ol>
<h2 id="自定义权限-eng"><a href="https://developer.android.google.cn/guide/topics/permissions/defining">自定义权限 Eng</a></h2>
<h1 id="第二部分-设备-device">第二部分 设备 Device</h1>
<h1 id="应用兼容性-device-compatibility">应用兼容性 Device compatibility</h1>
<h2 id="概述">概述</h2>
<h3 id="设备特征feature-id">设备特征（Feature ID）</h3>
<p>​	为了使你的应用在用户设备上可以正常使用，<code>Android</code>为硬件和软件设置了<code>特征ID</code>。硬件比如加速器传感器，它的特征ID是<code>FEATURE_SENSOR_COMPASS</code>；软件比如小部件widget，他的特征ID是 <code>FEATURE_APP_WIDGETS</code></p>
<p>​	假如你的应用是基于某项特征运作的，并且你不希望没有该特征的设备安装你的应用，你就可以在清单文件中使用<code>&lt;user-feature&gt;</code>来作出限制。</p>
<blockquote>
<p>例如，假设你的应用在没有加速度传感器的设备上会无法使用。这时你就可以在清单文件中加入</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.sensor.compass&quot;
                  android:required=&quot;true&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>
<p>这样，用户在持有没有加速度传感器的设备在Google Play Store下载该应用时就会被拒绝安装。</p>
<p>如果你的应用并不是一定需要该特征的话，你也可以把<code>android:required=&quot;true&quot;</code>的<code>true</code>改为<code>false</code>，然后在运行时判断设备是否具有该特征。如果没有的话再选择停用使用了该特征的功能。</p>
<pre><code class="language-java">PackageManager pm = getPackageManager();
//判断是否具有某特征ID
if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) {
    // This device does not have a compass, turn off the compass feature
    disableCompassFeature();
} 
</code></pre>
</blockquote>
<blockquote>
<p><strong>注意</strong>⚠️：某些系统的权限（<code>permission</code>）会隐式的检查设备是否具有特征（<code>feature ID</code>）。</p>
<p>比如，如果你的应用请求了蓝牙的使用权限：</p>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;
</code></pre>
<p>那Google Play Store就会自动隐式检测设备是否具有蓝牙硬件，若没有的话就会拒绝安装。</p>
<p>如果不想被隐式检查的话就需要手动设置</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.bluetooth&quot;
                  android:required=&quot;false&quot; /&gt;
    ...
&lt;/manifest&gt; 
</code></pre>
</blockquote>
<h3 id="平台版本-platform-version">平台版本 Platform version</h3>
<p>​	因为<code>Android</code>系统的向后兼容特性，我们需要在<a href="https://developer.android.google.cn/studio/build/index.html#build-files"><code>build.gradle</code></a>中设置<code>SdkVersion</code>以保证我们的应用可以正常工作。<br></p>
<pre><code class="language-java">android {
  defaultConfig {
    applicationId 'com.example.myapp'

    // 安装该应用的所需的最低版本API
    minSdkVersion 15

    // 在所有测试设备中，最高API设备的API
    targetSdkVersion 28

    ...
  }
}
</code></pre>
<p>​	<strong>注意⚠️</strong>：<br>	1. 如果<code>manifest</code>和<code>build.gradle</code>中同时设置了<code>minSdkVersion</code> and <code>targetSdkVersion</code>，则以<code>build.gradle</code>为准<br>	2.  <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target"><code>targetSdkVersion</code></a>并不会阻止高于它的设备安装该应用，但是需要注意的是，它决定了该应用是否继承新版本的更改。<br>	例如：</p>
<blockquote>
<p>在<code>Android4.4</code>更新中，为了省电，使用<code>AlarmManager API</code>创建的警报由之前的「准时提醒」改为了「批量同时提醒」</p>
<blockquote>
<p>二者区别：倘若创建了16:01:00和16:01:30两个时间的警报，旧版本会提醒两次，而新版本会合并为一次同时提醒2个事件。比之前减少一次唤醒，节省电量。</p>
</blockquote>
<p>倘若应用<code>targetSdkVersion</code>设置为最新版本，则在运行时警报提醒会变为「批量同时提醒」；而若是没有及时更新<code>targetSdkVersion</code>，则应用在运行时还是会「准时提醒」</p>
</blockquote>
<h2 id="不同屏幕尺寸兼容">不同屏幕尺寸兼容</h2>
<h3 id="使用最小宽度限定符">使用最小宽度限定符</h3>
<p><code>res/layout/main.xml</code>即代表默认布局，<code>res/layout-sw600dp/main.xml</code>即代表屏幕宽度大于等于 600dp 的设备所使用的布局。</p>
<h3 id="使用布局别名">使用布局别名</h3>
<p>​	因为最小宽度限定符只能使用在 Android3.2 以上的设备上面，所以当设备版本号低于 Android3.2 时，仍然会出现布局出错的问题，这是我们就需要专门为 Android3.2 以下的设备新建一个<code>res/layout-large</code>文件夹用来放置适配UI。<br>	可是为了适配 Android3.2 以下的设备专门新开一个文件夹，其中所有的资源都要从<code>res/layout-sw600dp/main.xml</code>复制一份，一方面浪费空间，另一番面后续维护容易遗漏。这时我们就可以使用布局别名。<br>	首先新建一个<code>res/layout/main_twopanes.xml</code>用来放置大尺寸屏幕下的布局和资源，然后修改<code>res/values-large/layout.xml</code>和``res/layout-sw600dp/main.xml`为下：</p>
<pre><code class="language-xml">&lt;resources&gt;
    &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;
&lt;/resources&gt;
</code></pre>
<h3 id="9-格式位图">. 9 格式位图</h3>
<p>​	支持不同尺寸的屏幕，意味着图像资源也需要能够适应不同的尺寸。而在图片的缩放上，经常会出现差强人意的效果，这时我们就可以使用 . 9格式的位图，来固定哪部分可以被缩放拉伸，而哪部分不可以。<br>	例如可用于对话消息框背景，能够在消息文本多少不确定的情况下保持眼睛不变形：<img src="https://upload-images.jianshu.io/upload_images/291600-66b458ac8f0909f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/901" alt="" loading="lazy"><br>	将图像格式改为 <code>.9.png</code>即可使图片成为 .9 格式并支持自定义拉伸位置。左边和上边区域定义可以拉伸的位置，而右边和下边定义图片中内容填充的位置。</p>
<h2 id="适配刘海屏-eng"><a href="https://developer.android.google.cn/guide/topics/display-cutout">适配刘海屏 Eng</a></h2>
<h2 id="声明受限屏幕的支持">声明受限屏幕的支持</h2>
<p>因为一些原因可能我们不想使一个apk同时支持所有屏幕比例的设备，这时我们可以作出一些限制。</p>
<ol>
<li>
<p><a href="https://developer.android.google.cn/training/multiple-apks/screensize.html">针对不同屏幕单独发布apk（依赖Google Play）</a></p>
</li>
<li>
<p>声明最大长宽比<br></p>
<p>​	可以设定一个最大长宽比，当应用在屏幕长宽比超过限定的设备上运行时，应用会做出适配。如果应用定位到 API 26 或更高版本会根据其布局填充屏幕；而 API 25 或更低版本会将应用界面大小限制为长宽比为 16:9 的窗口，手机屏幕将带有黑边运行应用。</p>
<p>​	要为 Android 8.0（API 级别 26）和更高版本设置最大长宽比，请在您的 <code>&lt;activity&gt;</code> 标记中使用 <code>android:MaxAspectRatio</code> 声明最大比例。</p>
<pre><code class="language-xml">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --&gt;
&lt;!-- Use a letterbox on screens larger than 2.4 --&gt;
&lt;activity android:maxAspectRatio=&quot;2.4&quot;&gt;
 ...
&lt;/activity&gt;
</code></pre>
<p>对于 Android 7.1 及更低版本，请在 <code>&lt;application&gt;</code>元素中添加一个 名为 <code>android.max_aspect</code> 的 <code>&lt;meta-data&gt;</code> 元素。</p>
<pre><code class="language-xml">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --&gt;
&lt;!-- Use a letterbox on screens larger than 2.4 --&gt;
&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.4&quot; /&gt;
</code></pre>
<p>如果设置了最大长宽比，请勿忘记同时设置 <code>android:resizeableActivity false</code>。</p>
<blockquote>
<p>有些设备支持分屏模式（同屏多应用）下使用，并且许多应用还支持可调整大小。如果不希望自己的应用支持该模式的话，可以为整个应用或特定 Activity 明确设置 <code>android:resizeableActivity flase</code>属性。</p>
<blockquote>
<p>分屏模式只适用于在 Android 7.0（API 级别 24）或更高版本中运行的所有应用，并且应用默认可调整大小。</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>注⚠️：<strong>如果您的应用不可调整大小，您应该在尽可能多的设备上测试它的行为。 检查所有控件是否均可见。 因为有些设备可让用户</strong>强制</strong>应用进入全屏显示，这会调整这些应用的大小。</p>
</blockquote>
</li>
<li>
<p>声明最大屏幕尺寸<br></p>
<p>​	即使并未完全优化您的应用以<a href="https://developer.android.google.cn/training/multiscreen/screensizes.html">支持不同的屏幕尺寸</a>，Android 仍然可以拉伸大部分应用以适应较大的屏幕。 因此，<strong>几乎从来都没有必要</strong>声明最大屏幕尺寸。</p>
<p>​	不过如果对于 Android 调整应用以适应大屏幕的方式不满意，则可通过在 <code>&lt;supports-screens&gt;</code> 清单标记中指定 <a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#largestWidth"><code>largestWidthLimitDp</code></a> 属性来禁止将大小调整到超出特定宽度。 然后，Android 会启用<a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#compat-mode">屏幕兼容模式</a>（此模式会按照应用支持的最大尺寸屏幕上的绘制方式来绘制布局，然后<strong>放大所有像素以填充屏幕</strong>），<strong>而不是调整布局的大小</strong>。</p>
</li>
<li>
<p>限制应用仅支持平板电脑或电视<br></p>
<p>​	可以使用<code>&lt;supports-screens&gt;</code> <code>manifest</code>元素来阻止手机设备下载您的应用。<br>	例如，以下代码声明只有大屏幕和特大屏幕才能安装您的应用：</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;supports-screens android:smallScreens=&quot;false&quot;
                      android:normalScreens=&quot;false&quot;
                      android:largeScreens=&quot;true&quot;
                      android:xlargeScreens=&quot;true&quot;/&gt;
    ...
&lt;/manifest&gt;
</code></pre>
</li>
<li>
<p>限制应用仅支持特定尺寸和密度<br></p>
<p>​	可以使用<code>&lt;compatible-screens&gt;</code>manifest 元素来定义应用支持的确切屏幕尺寸和密度。 但是，<strong>强烈建议不要</strong>使用此功能，因为未指定的任何尺寸和密度组合都会被视为与应用不兼容的屏幕配置。<br>	<code>&lt;compatible-screens&gt;</code>元素必须包含一个或多个 <code>&lt;screen&gt;</code> 元素。 每个 <code>&lt;screen&gt;</code> 元素都使用 <code>android:screenSize</code> 和 <code>android:screenDensity</code> 属性指定与您的应用兼容的屏幕配置 。 每个 <code>&lt;screen&gt;</code> 元素都<strong>必须同时包含这两个属性</strong>才能指定一个屏幕配置 — 缺少任一属性都会导致该元素无效。<br>	例如，如果您的应用仅与小屏幕尺寸和标准屏幕尺寸（以及一部分屏幕密度）兼容，则 manifest 项将如下所示：</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;compatible-screens&gt;
        &lt;!-- all small size screens --&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;ldpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;mdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;hdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;xhdpi&quot; /&gt;
        &lt;!-- all normal size screens --&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;ldpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;mdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;hdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;xhdpi&quot; /&gt;
    &lt;/compatible-screens&gt;
    ...
    &lt;application ... &gt;
        ...
    &lt;application&gt;
&lt;/manifest&gt;
</code></pre>
<p>未在此处明确声明的任意尺寸和密度组合都将受到限制，无法安装该应用。</p>
</li>
</ol>
<h2 id="多种-apk-支持选修"><a href="https://developer.android.google.cn/google/play/publishing/multiple-apks">多种 APK 支持（选修）</a></h2>
<p>​	依赖 Google Play 平台，故选修。</p>
<h2 id="支持不同平台版本">支持不同平台版本</h2>
<h3 id="运行时检查系统版本">运行时检查系统版本</h3>
<p>​	Android 在 Build constant 类中为每个平台版本都提供了独特的代码，在应用中使用这些代码来构建条件，以确保可用这些 API 时才会去执行这些代码。<br>	例如：</p>
<pre><code class="language-java">private void setUpActionBar() {
    // Make sure we're running on Honeycomb or higher to use ActionBar APIs
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
    }
}
</code></pre>
<blockquote>
<p>注：解析 xml 资源时，Android会自动忽略当前设备不支持的 xml 属性。也就是说，对于 xml 资源而言，不需要担心新的属性在旧版本设备上崩溃或报错，因为旧设备会自动忽略掉不认识的属性，不需要像代码一样提前判断版本再操作。</p>
<p>例如： 如果您设置targetSdkVersion =“11”，则默认情况下，您的应用会在Android 3.0及更高版本中包含ActionBar。如果要在 ActionBar 中添加菜单项，您需要在菜单资源 XML 中设置<code>android：showAsAction =“ifRoom”</code>。 而在跨版本的 XML 文件中执行此操作是安全的，因为旧版本的 Android 因为不认识 showAsAction 属性而会忽略掉它（也就是说，您不需要专门区分出一个<code>res/menu-v11/</code>）。</p>
</blockquote>
<h3 id="使用不同主题样式">使用不同主题样式</h3>
<p>​	Android 提供了许多主题样式，可以在 manifest 清单文件中自定义。当你使用了这些主题后，你的应用会自动适配为 Android 最新版的外观和感觉样式。</p>
<p>想让你的 Activity 看起来像个对话框：</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@android:style/Theme.Dialog&quot;&gt;
</code></pre>
<p>想让你的 Activity 有个透明的背景：</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@android:style/Theme.Translucent&quot;&gt;
</code></pre>
<p>想让你的活动使用你自己的主题（自定义主题需要放在 <code>/res/values/styles.xml</code>下）</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@style/CustomTheme&quot;&gt;
</code></pre>
<p>想让你的整个应用所有 Activity 都使用某种主题，在<code>&lt;application&gt;</code>中添加<code>android:theme</code> 属性即可</p>
<pre><code class="language-xml">&lt;application android:theme=&quot;@style/CustomTheme&quot;&gt;
</code></pre>
<p>更多的自定义主题设计可以看<a href="https://developer.android.google.cn/guide/topics/ui/themes.html">风格主题向导</a></p>
<h2 id="google-play-上的过滤器选修">Google Play 上的过滤器（选修）</h2>
<p>使用场景：当用户在 Google Play 上搜索或浏览应用以下载时，会根据哪些应用与其设备兼容来过滤搜索结果。</p>
<h1 id="android-wear"><a href="https://developer.android.google.cn/training/wearables">Android Wear</a></h1>
<h1 id="android-tv"><a href="https://developer.android.google.cn/training/tv">Android TV</a></h1>
<h1 id="android-auto"><a href="https://developer.android.google.cn/training/auto">Android Auto</a></h1>
<h1 id="android-things"><a href="https://developer.android.google.cn/things/get-started">Android Things</a></h1>
<h1 id="chrome-os-devices"><a href="https://developer.android.google.cn/chrome-os/intro">Chrome OS Devices</a></h1>
<h1 id="核心内容-eng-日后填坑"><a href="https://developer.android.google.cn/guide/components/activities/intro-activities">核心内容 Eng 日后填坑</a></h1>
<h1 id="完美测试-eng-日后填坑"><a href="https://developer.android.google.cn/training/testing">完美测试 Eng 日后填坑</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github Page + jekyll搭建]]></title>
        <id>https://ArsenicX.github.io/github-page-jekyll-da-jian/</id>
        <link href="https://ArsenicX.github.io/github-page-jekyll-da-jian/">
        </link>
        <updated>2020-03-25T04:54:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-创建repository并pull到本地">一. 创建repository并pull到本地</h2>
<ol>
<li>这里需要注意Repository name一定要是自己的<code>Github账户名.github.io</code><img src="https://i.loli.net/2019/04/08/5caab7b46ea47.jpg" alt="Snipaste_2019-04-08_10-53-21.jpg" loading="lazy"></li>
<li>创建好了之后在设置页面添加一个默认的界面样式<br>这步是为了在你以后添加博文的时候会有个初始界面，否则你的新博文是不会显示的<br><img src="https://i.loli.net/2019/04/08/5caab883d88a9.jpg" alt="Snipaste_2019-04-08_10-56-54.jpg" loading="lazy"></li>
<li>将这个新建的项目pull到本地，并将该文件夹下除了<code>.git</code>之外其他文件全部删除（pull项目的具体操作可以看<a href="https://arsenicx.github.io/2018/08/17/git-commands/">Git 常用命令</a>）</li>
</ol>
<h2 id="二-创建自己的主页">二. 创建自己的主页</h2>
<blockquote>
<p>目前两大主流静态博客框架是jekyll和hexo，这里我选用了jekyll</p>
</blockquote>
<ol>
<li>在<a href="http://jekyllthemes.org/">Jekyll Themes</a>中下载一个自己中意的主题（比如<a href="http://jekyllthemes.org/themes/wiki-blog/">Wiki Blog</a>，以下的配置也是基于Wiki Blog的），将下载后的压缩包解压，并将其中所有东西移动到repository目录中。<br>此时在浏览器打开<code>https://arsenicx.github.io/</code>就能看到自己的主页了（记得把链接里面的名称换成自己的）</li>
<li>这时你的个人博客就搭建好了，repository目录下面的_posts文件夹就是你的博文放置的位置。<br>这时就可以用markdown格式来写你的第一篇博文了。</li>
</ol>
<h2 id="三-写自己的第一篇博文">三. 写自己的第一篇博文</h2>
<blockquote>
<p>有些主题可能强制要求在文章头必须写layout、title、date、categories等</p>
</blockquote>
<ol>
<li>正文的格式是markdown格式文本。</li>
<li>在本地修改完repository之后，用git命令提交到Github就可以了，然后过几分钟刷新自己博客的页面就可以看到改动了。</li>
<li>以下是我遇到的一些小问题，一并贴在这里</li>
</ol>
<ul>
<li>有些主题需要在开头之后至少空两行以上才能写正文</li>
<li>如果添加了博文之后，怎么刷新都不出现，则有可能是你的博文日期设置问题。<br>因为jekyll是根据UTC时间设置的，而北京时间是UTC+8的时区，时间过早所以会出现博文不显示的bug，此时只要在博文开头的data后添加一个<code>UTC+8</code>即可，如<code>date:2019-04-08 10:42:03UTC+8</code></li>
<li>当我把我的分类名<code>git_Github</code>改成<code>git&amp;Github</code>时，会发现在首页点击该分类无效了。个人怀疑是<code>&amp;</code>这个字符不能被支持，同样不支持的还有空格等字符。</li>
<li>网站的自定义icon：将自己想要的图片缩放至32*32像素，然后重命名为<code>favicon.ico</code>并放到repository根目录下就好了。可能会需要很久才能实现预览，不必着急。</li>
</ul>
<h2 id="四-win环境搭建本地的jekyll环境选修">四. win环境搭建本地的jekyll环境（选修）</h2>
<blockquote>
<p>目的：<br>每次更改完_post之后都要先提交到Github，然后等一会才能看到实际效果。对于新手来说，更开始不熟悉Markdown效果肯定会更多的使用git push，费时间和精力。<br>而搭建本地的jekyll环境就可以在本地修改完项目后实时预览到变化，待最终确定完博文之后再提交到Github即可。</p>
</blockquote>
<ol>
<li>首先安装Ruby，进入官网<a href="https://rubyinstaller.org/downloads/">下载页面</a>，下载“WITH DEVKIT”的版本。<br><img src="https://i.loli.net/2019/04/08/5caaedb34ea1f.jpg" alt="" loading="lazy"></li>
<li>安装过程中，<strong>建议不要改变任何路径，使用默认就好</strong>，并且建议<strong>选中【加入到环境变量中】</strong><br>（因为我已经安装完成了，下图只做说明选项，不用在意版本号和其他）<br><img src="https://i.loli.net/2019/04/08/5caaedbabcb37.png" alt="" loading="lazy"></li>
<li>安装完成之后会弹出一个命令行，是让你选择1，2，3来选择安装的，如果你不清楚区别的话按一下<code>Enter</code>回车就好，他会自动检测然后安装<br>（因为我已经安装完成了所以这里就不上图了）</li>
<li>待安装后在命令提示符中分别运行<code>ruby -v</code>和<code>gem -v</code>，结果如果会出现当前安装版本号，则说明此时可以安装jekyll了。<br><img src="https://i.loli.net/2019/04/08/5caaeff7764db.jpg" alt="Snipaste_2019-04-08_14-52-18.jpg" loading="lazy"><br>运行<code>gem install jekyll</code>来安装jekyll<br><img src="https://i.loli.net/2019/04/08/5caaeff7bb8c9.jpg" alt="Snipaste_2019-04-08_14-52-42.jpg" loading="lazy"></li>
<li>待安装后运行<code>jekyll --version</code>，出现版本号则说明安装成功。<br>然后将命令行路径移动到repository的目录下并运行<code>jekyll serve</code>，结果如下图的话，恭喜你，你已经搭建完成了本地的jekyll环境，其中红框所圈地址即为你的博客的本地路径，改动过repository后浏览器输入该地址并刷新即可实时预览<br><img src="https://i.loli.net/2019/04/08/5caaf215bb09f.jpg" alt="Snipaste_2019-04-08_15-02-33.jpg" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git连接Github]]></title>
        <id>https://ArsenicX.github.io/git-lian-jie-github/</id>
        <link href="https://ArsenicX.github.io/git-lian-jie-github/">
        </link>
        <updated>2020-03-25T04:53:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-配置ssh">一. 配置SSH</h2>
<ol>
<li>
<p>打开git，运行<code>ssh</code>。<br>如果打印以下消息，则说明ssh配置成功。<br><img src="https://i.loli.net/2019/04/07/5ca9e82a7cfd7.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p>运行<code>ssh-keygen -t rsa</code>，用来生成和GitHub关联的key。<br>如果打印以下消息，则说明ssh key生成成功。其中红框部分是ssh key生成的位置。<br><img src="https://i.loli.net/2019/04/07/5ca9eb6958292.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p>进入上图红框处ssh key的位置，并打开id_rsa.pub，复制其中的key文本。<br><img src="https://i.loli.net/2019/04/07/5ca9eb695f4bc.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>给自己的Github账户添加上一步复制的ssh key，如图操作或者直接<a href="https://github.com/settings/ssh/new">点击我</a>打开页面<br>
<br><img src="https://i.loli.net/2019/04/07/5ca9eb69641d0.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>git运行<code>ssh -T git@github.com</code>，第一次时会弹出警告，此时输入<code>YES</code>即可<br>
<br>结果如下图则说明连接成功。<br><img src="https://i.loli.net/2019/04/07/5ca9ee4b32026.jpg" alt="Snipaste_2019-04-07_20-34-03.jpg" loading="lazy"></p>
</li>
</ol>
<h2 id="二-连接github-repository">二. 连接Github repository</h2>
<ol>
<li>在github上添加新repository（如果已有可以跳过此步骤）<br>（具体步骤省略）</li>
<li>将git命令行的当前路径移动到自己想要保存repository的目录<br>
<br></li>
<li>运行<code>git clone https://github.com/ArsenicX/ArsenicX.github.io.git</code>，<br>
该地址位置如下图：<br>
<img src="https://i.loli.net/2019/04/07/5ca9f095ae601.jpg" alt="" loading="lazy"></li>
</ol>
<br>
参考：https://www.jianshu.com/p/5ad1ae0f7efd
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String]]></title>
        <id>https://ArsenicX.github.io/string/</id>
        <link href="https://ArsenicX.github.io/string/">
        </link>
        <updated>2020-03-25T04:52:29.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>与Char转换</p>
</li>
<li>
<p>charAt()：类似于数组，取出特定位置字符 <code>char c = s.charAt(1);</code></p>
</li>
<li>
<p>toCharArray()：将字符串转换为一个字符数组 <code>char[] arr = s.toCharArray();</code></p>
</li>
<li>
<p>字符串逆置</p>
</li>
<li>
<pre><code></code></pre>
</li>
</ul>
<p>for(int i = 0;i&lt;s.length();i++){<br>
System.out.print(s.charAt(s.length()-i-1));<br>
}</p>
<pre><code>- ```
StringBuilder stringBuilder = new StringBuilder(str);
StringBuilder str2 = stringBuilder.reverse();
return str2.toString();
</code></pre>
<ul>
<li>字符串排序</li>
<li>
<pre><code></code></pre>
</li>
</ul>
<p>char array[]=s.toCharArray();<br>
Arrays.sort(array);<br>
for(char a:array){<br>
System.out.println(a);<br>
}</p>
<pre><code></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合]]></title>
        <id>https://ArsenicX.github.io/ji-he/</id>
        <link href="https://ArsenicX.github.io/ji-he/">
        </link>
        <updated>2020-03-25T04:52:04.000Z</updated>
        <content type="html"><![CDATA[<p>Java的集合类主要由Collection和Map接口派生。</p>
<h1 id="collection接口">Collection接口</h1>
<p>Collection有3个子接口：List（顺序表）、Set（堆）、Queue（队列）</p>
<h2 id="list">List</h2>
<p>List常见的实现类是ArrayList、Vector和Stack（栈）<br>
ArrayList是非线程安全的，在多线程下需要手动保证集合的同步性；而Vector是线程安全的<br>
但是因为性能较差和有其他诸多缺点，在实际使用中仍然不推荐使用Vector。建议使用ArrayList并搭配Collections工具类保证线程安全</p>
<h2 id="set">Set</h2>
<p>Set常见的实现类是HashSet，还有TreeSet和EnumSet（专为枚举类设计）<br>
HashSet的存储类似使用链地址法解决冲突的哈希表</p>
<h2 id="迭代器iterator">迭代器：Iterator</h2>
<p>Iterator接口是Collection的父接口，因此可以使用Collection.iterator()获取到Iterator，然后访问、操作数据</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
Iterator&lt;String&gt; iterator = list.iterator();
while(iterator.hasNext()){
    System.out.println(iterator.next())
}
</code></pre>
<h2 id="集合工具类">集合工具类</h2>
<p>Java还提供了两个较为实用的辅助工具类Collections和Arrays</p>
<h1 id="map接口键值对">Map接口（键值对）</h1>
<p>Map常见的实现类有HashMap和TreeMap</p>
<pre><code>HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;&gt;();
hashMap.put(1,&quot;aa&quot;);
System.out.println(hashMap.get(1))
</code></pre>
<h1 id="集合转换">集合转换</h1>
<p>将Map集合转换为Collection集合有3种方法：entrySet()、keySet()和values()，这三种方法分别返回键值对集合、键的集合和值的集合</p>
<pre><code>HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;&gt;();

//使用entrySet获取Entry键值对集合
Set&lt;Entry&lt;Integer,String&gt;&gt; set = hashMap.entrySet();
for(Entry&lt;Integer,String&gt; entry: set){
    System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());
}

//使用keySet获取键集合（使用values获取值集合类似）
Set&lt;Integer&gt; set = hashMap.keyySet();
for(Integer key: keySet){
    System.out.println(key);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 总结]]></title>
        <id>https://ArsenicX.github.io/java-zong-jie/</id>
        <link href="https://ArsenicX.github.io/java-zong-jie/">
        </link>
        <updated>2020-02-18T15:02:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="入门">入门</h2>
<ul>
<li>成员变量不赋值就可以直接使用，int、byte等类型为0，boolean为fault，引用类型为null<br>局部变量必须先赋值，才能使用</li>
<li>final：
<ul>
<li>修饰类--------表示其不能被继承，即最终类</li>
<li>修饰方法-----表示其不能被重写，即最终方法</li>
<li>修饰变量-----表示其不能被修改，即常量</li>
</ul>
</li>
<li>abstract：
<ul>
<li>如果当前类有抽象方法，或继承自一个抽象类/抽象接口，但没有全部实现该类/该接口的抽象方法，则必须定义为抽象类<br>抽象类可以包含成员变量及构造方法，但不能被实例化，即不能new</li>
<li>不能用来修饰成员变量和构造方法</li>
<li>不能用private修饰，不能和static，final，native同时修饰同一方法</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/nvd11/article/details/18706087">Java 里的 abstract 和 final 关键字</a></li>
</ul>
<h2 id="进阶">进阶</h2>
<ul>
<li>
<p>继承 &amp; 多态 &amp; 接口： <em>instanceof</em> 类来判断该引用型变量所指向的对象是否属于该类或该类的子类</p>
<ol>
<li>继承：<br>子类的修饰权限和父类必须要保持一致或更加公开<br>在构造子类对象的时候，会首先调用父类的无参构造方法；如果父类没有无参构造方法，则报错<br>如果要在子类的构造方法中明确写出调用基类方法super( )的话，则需要写在子类构造方法的<strong>第一行</strong></li>
<li>多态：<br>子类方法的可访问性和父类必须要保持一致或更加公开<br>父类的私有方法不能被重写，即使子类中定义了一个同名的方法，也是一个新的方法，和父类方法无关<br>不能重写静态方法</li>
<li>接口：<br>接口中定义的成员变量都是 static &amp; final<br>接口中定义的方法默认是、也只能是public类型；同时也只能是抽象方法（abstract，不能有方法体）、默认方法（必须用default修饰）或类方法（static）</li>
</ol>
</li>
<li>
<p>异常：</p>
<ol>
<li>
<p>Try  Catch：<br>
用竖线使一个try catch捕获多个异常，但是这种方式捕捉到的异常不能重新赋值，只能是e</p>
<pre><code>try{...}
catch(NumberFormatException  | ArithmeeticException e) {...}
</code></pre>
<p>即使catch中有return，代码也会执行finally中的语句，除非catch中有System.exit( )（退出应用程序）<br>执行内部的try如果没有遇到匹配的catch块，则检查外部的catch块</p>
</li>
<li>
<p>Throw/ Throws：<br>throw用于try语句中，在可能出现异常的语句中 throw new Exception(&quot;... ...&quot;)<br>throws用于方法外部，如果自定义的方法可能会抛出异常，则方法名外加上 throws IOException,Exception....，然后在调用该方法的地方使用catch捕获</p>
</li>
<li>
<p>自定义异常：如果总是在运行时产生异常，且不易预测在什么时候发生异常，则定义为RuntimeException；否则定义为Exception</p>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
</feed>