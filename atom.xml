<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ArsenicX.github.io/</id>
    <title>ArsenicX</title>
    <updated>2020-04-26T15:03:16.145Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ArsenicX.github.io/"/>
    <link rel="self" href="https://ArsenicX.github.io/atom.xml"/>
    <logo>https://ArsenicX.github.io/images/avatar.png</logo>
    <icon>https://ArsenicX.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ArsenicX</rights>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://ArsenicX.github.io/cao-zuo-xi-tong/</id>
        <link href="https://ArsenicX.github.io/cao-zuo-xi-tong/">
        </link>
        <updated>2020-04-13T11:23:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考书目：《计算机操作系统（第四版）》 - 西安电子科技大学出版社<br>
编排顺序：依靠参考书顺序</p>
</blockquote>
<h1 id="第一章操作系统引论">第一章：操作系统引论</h1>
<h2 id="第一节os的作用">第一节：OS的作用</h2>
<ol>
<li>OS是用户与计算机硬件系统之间的接口<br>
<img src="https://ArsenicX.github.io//post-images/1586778608519.png" alt="" loading="lazy"></li>
<li>OS是计算机系统资源的管理者</li>
<li>OS实现了对计算机资源的抽象<br>
<img src="https://ArsenicX.github.io//post-images/1586778620197.png" alt="" loading="lazy"></li>
</ol>
<h2 id="第二节os的发展过程略">第二节：OS的发展过程（略）</h2>
<h2 id="第三节os的基本特性">第三节：OS的基本特性</h2>
<h3 id="1-并发">1. 并发：</h3>
<ol>
<li>并行&amp;并发<br>
并行性：多个事件同一时刻发生<br>
并发性：多个事件同一时间间隔发生</li>
<li>进程（第二章详讲）<br>
进程是指系统中独立运行并作为资源分配的基本单位，它是由一组机器指令数据和堆栈等组成的。是一个能独立运行的活动实体</li>
</ol>
<h3 id="2-共享">2. 共享：</h3>
<p>有两种实现方式：</p>
<ol>
<li>互斥共享：主要针对于临界资源</li>
<li>同时访问：针对于其他资源，比如磁盘设备。这里的同时，其实是宏观意义上的，在微观上看是交替进行的</li>
</ol>
<h3 id="3-虚拟将一条物理信道变成若干条逻辑信道">3. 虚拟：将一条物理信道变成若干条逻辑信道</h3>
<p>有两种技术可以实现虚拟：</p>
<ol>
<li>时分复用技术：可以用来处理虚拟机或设备
<ul>
<li>虚拟处理机：利用多道程序设计技术，为每道程序建立一个进程，让多道程序并发地执行，以此来分时使用一台处理机。此时，虽然系统中只有一台处理机，但它却能分时为多个用户服务。使每个终端用户都认为是有一个处理机在专门为他服务</li>
<li>虚拟设备：将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，这样便可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多用户“同时”访问的共享设备</li>
</ul>
</li>
<li>空分复用技术：<br>
类似于电信业中将一个频率范围非常宽的信道，划分成多个频率范围较窄的信道，然后使用其中的不同频率范围的信道供用户通话<br>
如果说时分复用技术是利用处理机的空闲时间运行其他程序（见缝插针）来提高<strong>处理机</strong>的利用率，那么空分复用技术就是存储器的空闲空间，分区域存放和运行其他多道程序，从而提高<strong>内存</strong>的利用率</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络]]></title>
        <id>https://ArsenicX.github.io/ji-suan-ji-wang-luo/</id>
        <link href="https://ArsenicX.github.io/ji-suan-ji-wang-luo/">
        </link>
        <updated>2020-03-27T01:30:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考书目：《计算机网络 第七版》</p>
</blockquote>
<h1 id="一-概述">一.  概述</h1>
<table>
<thead>
<tr>
<th>本章主要是简单介绍下计网中常见概念，以及我们要怎么学习计网 (分层思想)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="一-计算机网络的性能指标">一. 计算机网络的性能指标：</h2>
<ol>
<li>
<p>速率（车速）<br>
在表示速度速率时，1M=10<sup>6</sup></p>
</li>
<li>
<p>带宽（路宽）<br>
在表示带宽或者存储时，1M=2<sup>20</sup></p>
</li>
<li>
<p>吞吐量：在单位时间内<strong>实际</strong>通过某个网络的数据量，单位是b/s, Mb/s。</p>
</li>
<li>
<p>时延<br>
对于高速网络链路，我们提高的仅仅是数据的<strong>发送速率</strong>而不是比特在链路上的<strong>传播速率</strong>。传播速率取决于通信线路的材料<br>
通常我们所说的“光纤速度更快”，说的其实是光纤可以以更高的速度向光纤信道<strong>发送数据</strong>，而不是指信号在光纤中<strong>传播速度</strong>要比在铜线中快。实际上，光在光纤中的传播速度（20.5万公里/秒）确实要比电磁波在铜线中的传播速度（23.1万公里/秒）要低一些</p>
</li>
<li>
<p>时延X带宽(时延带宽积)：有多少数据正在线路上。<br>
<img src="https://ArsenicX.github.io//post-images/1585280298420.png" alt="" loading="lazy"></p>
</li>
<li>
<p>利用率<br>
要注意，信道利用率并非越高越好，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加；可以类比于公路上车辆越多，公路的利用率就越高，但是不可避免地就会造成堵车。<br>
网络当前时延D = 网络空闲时的时延D<sub>0</sub> / (1 - 信道利用率U)<br>
因此，对于一些较大的主干网的ISP，他们通常会将利用率控制在50%以下。</p>
</li>
</ol>
<h2 id="二-通信协议具体内容看之后各章">二. 通信协议（具体内容看之后各章）：</h2>
<h3 id="1-osi参考模型">1. OSI参考模型：</h3>
<ul>
<li>应用层——所有能产生网络流量的程序</li>
<li>表示层——在传输之前是否进行加密 或 压缩 处理，二进制或ASCII码表示</li>
<li>会话层——查木马，看需求端和网站之间的连接</li>
<li>传输层——可靠传输，流量控制，不可靠传输(一个数据包即可，不需要建立会话，例如向DNS查询网站IP地址)</li>
<li>网络层——负责选择最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)</li>
<li>数据链路层——帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)</li>
<li>物理层——定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快</li>
</ul>
<ol>
<li>
<p>OSI参考模型对网络排错的意义：每一层都为上一层提供服务，一旦某一层崩了，上面所有层都崩了，所以排查问题从最底层(物理层)排查；</p>
<ol>
<li>物理层故障怎么办？<br>
查看链接状态，发送和接收的数据包数值；</li>
<li>数据链路层故障怎么办？<br>
Mac地址冲突，2个一样的Mac地址同时访问；ADSL(非对称数字用户线路)欠费；两端的接口网速没有协商一致；计算机连接到其它VLAN(虚拟互联网)中。</li>
<li>网络层故障怎么办？<br>
配置错误的IP地址，子网掩码，网关；数据有没有通过各个网关到达指定位置；</li>
<li>应用层(合并3层)故障怎么办？<br>
应用程序配置问题</li>
</ol>
</li>
<li>
<p>OSI参考模型和网络安全解决办法：</p>
<ol>
<li>物理层安全隐患？<br>
别人能私自接入你的网络，应该拔掉不用的网线或接口；</li>
<li>数据链路层安全隐患？<br>
ADSL账号密码，VLAN，交换机端口绑定Mac地址</li>
<li>网络层安全隐患？<br>
路由器上使用ACL(访问控制列表)控制数据包流量；防火墙设置；</li>
<li>应用层安全隐患？<br>
应用程序有没有漏洞</li>
</ol>
</li>
</ol>
<h3 id="2-5层协议数据传递图">2. 5层协议数据传递图</h3>
<figure data-type="image" tabindex="1"><img src="https://ArsenicX.github.io//post-images/1585280314002.png" alt="" loading="lazy"></figure>
<h3 id="3-当今">3. 当今</h3>
<p>现如今，技术的发展并不是遵循严格的 OSI 分层概念。实际上现在的互联网使用的 TCP/IP 体系结构有时已经演变成为下图所示那样<br>
<img src="https://ArsenicX.github.io//post-images/1585280321601.png" alt="" loading="lazy"><br>
<img src="https://ArsenicX.github.io//post-images/1585280323758.png" alt="" loading="lazy"></p>
<h1 id="二-物理层">二. 物理层</h1>
<table>
<thead>
<tr>
<th>首先先说说物理层是用来干什么的，以及一些后面会涉及到的知识</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="一-基本概述">一. 基本概述</h2>
<p>物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：</p>
<ul>
<li>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li>
<li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li>
<li>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</li>
<li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<h2 id="二-数据通信的基本知识给非通信工程专业看的用于接轨后续学习">二. 数据通信的基本知识（给非通信工程专业看的，用于接轨后续学习）</h2>
<ol>
<li>
<p>数据通信系统模型<br>
<img src="https://ArsenicX.github.io//post-images/1585279750821.png" alt="" loading="lazy"><br>
在数字信号中有<code>码元</code>这一概念：<code>码元</code>就是在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<blockquote>
<p>用人话讲，就是表示数字信号时，横轴的一个单位格就是一个码元。如图中，一个码元就代表一个0或者1<img src="https://ArsenicX.github.io//post-images/1585290057339.png" alt="" loading="lazy"></p>
</blockquote>
<p>一个码元所携带的信息量不是固定的，可以是1个，也可以是n个</p>
<blockquote>
<p>举例子：如果一个码元携带3个信息，则其携带的信息就有8种：从000到111<br>
<img src="https://ArsenicX.github.io//post-images/1585290329066.png" alt="" loading="lazy"></p>
</blockquote>
</li>
<li>
<p>有关信道的基本概念<br>
<code>信道</code>一般表示向<strong>一个方向</strong>传输信息的媒体。所以通信线路往往包含一条发送信息的信道和一条接收信息的信道。</p>
<ul>
<li>单向通信(单工通信)——只能有一个方向的通信，没有反向交互。比如电视机</li>
<li>双向交替通信(半双工通信)——通信的双方都可以发送信息，但是不能双方同时发送或接收。比如对讲机，一方说完才能另一方说</li>
<li>双向同时通信(全双工通信)——通信的双发可以同时发送和接收。比如电话</li>
</ul>
<p><code>基带信号</code>表示这些来自信源的信号，例如计算机输出的代表各种文字或图像文件的数据信号。基带信号往往包含了很多低频成分，然而这种低频成分并不能被许多信道传输，所以我们需要对基带信号进行<code>调制</code></p>
<p><code>调制</code>分为了两大类<br>一类是仅仅对基带信号的波形进行变换，<strong>变换后仍然是基带信号</strong>。这类调制称为<code>基带调制</code>或<code>编码</code>。<br>另一类调制需要使用载波（carrier）进行调制，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），<strong>变换后的信号称为<code>带通信号</code></strong>。这类使用载波进行的调制称为<code>带通调制</code></p>
<p>常见的 <code>基带调制</code>/<code>编码</code>：<br>
<img src="https://ArsenicX.github.io//post-images/1585289186730.png" alt="" loading="lazy"><br>
基本的 <code>带通调制</code>：<br>
<img src="https://ArsenicX.github.io//post-images/1585289426781.png" alt="" loading="lazy"></p>
</li>
<li>
<p>信道极限容量（简单举例讲解，具体学习去看通信专业相关书籍）<br>
从概念上讲，限制码元在信道上传输速率的因素有2个：</p>
<ol>
<li>
<p>码间串扰：高频分量在传输时受到衰减，波形的前沿和后沿不再陡峭，每个码元的界限也不再明确的这种现象<img src="https://ArsenicX.github.io//post-images/1585296810369.png" alt="" loading="lazy"><br>
面对这种现象，Nyquist 推导出了奈氏准则。这个准则给出了在理想条件下(无噪声/干扰/失真)，为了避免码间串扰，码元的传输速率的上限；如果超过了该上限，则会出现严重的码间串扰的问题。<br>
当然如果信道的频带很宽(信号高频分量很多)，则用更高的速率传输码元也不会出现码间串扰。</p>
</li>
<li>
<p>信噪比：信息的平均功率和噪声的平均功率之比，常记为：S/N，单位为分贝(dB)<br>
即：信噪比(dB) = 10 * log<sub>10</sub>(S/N) <br><br>
1948年Shannon推导出了香农公式：<br>
信道的<strong>极限</strong>信息传输速率C(bits/s) = 信道的带宽W * log<sub>2</sub>(1 + S/N) <br><br>
由上式可看出，虽然噪声存在于所有电子设备中，无法避免。但是如果信噪比越高，则信息传输速率就越高。<br>
而具体的方式比如有提高频带宽度、提高码元传输速率和<strong>让每一个码元携带更多的比特信息量</strong></p>
</li>
<li>
<p>奈氏准则和香农公式的应用范围<br>
<img src="https://ArsenicX.github.io//post-images/1585297117204.png" alt="" loading="lazy"></p>
</li>
</ol>
</li>
</ol>
<h2 id="三-物理层中的传输介质">三. 物理层中的传输介质</h2>
<p>可分为两类：导向传输媒体 和 非导向传输媒体</p>
<ol>
<li>导向传输媒体：双绞线(屏蔽和无屏蔽)、同轴电缆、光缆(多模和单模)等</li>
<li>非导向传输媒体：无线电、卫星、微波...</li>
</ol>
<blockquote>
<p>具体这两类的常见线材和特点就略去了，非计算机网络重点<br>
下面只简单介绍一个常见的水晶头</p>
</blockquote>
<p>通常来说，相同类型的设备之间需要连接的要用交叉线，而不同类型的设备之间用直通线<br>
水晶头直通线为 568B标准，交叉线为 568A标准：<br>
<img src="https://ArsenicX.github.io//post-images/1585299518930.png" alt="" loading="lazy"></p>
<p>目前电信领域使用的电磁波频谱：<img src="https://ArsenicX.github.io//post-images/1585299588336.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>物理线路是用来传输数据的，那怎么才能做到用最少的线路去最多最快的传送数据呢？这就用到了复用技术</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="四-信道复用技术">四.  信道复用技术</h2>
<p>在以前，都是和图2-13 (a) 一样，一根线只传一种东西，十分低效；后来便开始用了复用技术：<br>
<img src="https://ArsenicX.github.io//post-images/1585302184765.png" alt="" loading="lazy"><br>
<img src="https://ArsenicX.github.io//post-images/1585302415605.png" alt="" loading="lazy"></p>
<p>分类：</p>
<ol>
<li>频分复用(FDM，frequency division multiplexing)：<br>
用户在分配到一定的频带后，在通信过程中始终站用这个频带。</li>
<li>时分复用(TDN，time division multiplexing)<br>
时分复用是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。因此TDM 信号也称为等时<br>
<img src="https://ArsenicX.github.io//post-images/1587813139647.png" alt="" loading="lazy"></li>
</ol>
<pre><code>   当用户数量增多时：
   在频分复用下，信道的总带宽也会增多：
        假如一个用户的带宽是4kHz，则100个用户频分复用后总带宽就变成了4MHz
   在时分复用下：
        假设每个用户分配到的时隙宽度是125μs，则100个用户复用后每个用户的时隙宽度就变为了1.25μs
</code></pre>
<ol start="3">
<li>
<p>统计时分复用(STDM，statistic TDM)<br>
上图的时分复用，是在理想状态下是所有用户都在进行数据传送的原理图。但是实际情况一定存在用户空闲状态，没有进行数据传输的时候，那么这个时候就会造成浪费<img src="https://ArsenicX.github.io//post-images/1585303266106.png" alt="" loading="lazy"><br>
STDM应运而生，原理如下图。每一个STDM帧中的时隙数量都<strong>小于</strong>连接在集中器上的用户数量。在用户有数据后依次扫描缓存，没有数据的缓存就跳过；一个数据帧满了就发送。同时我们可以发现每个用户的出现并不是周期性的，所以STDM也称为<code>异步时分复用</code>，而普通的时分复用也称为<code>同步时分复用</code><img src="https://ArsenicX.github.io//post-images/1585303478581.png" alt="" loading="lazy"><br>
但是我们仍然能看到缺点：</p>
<ol>
<li>首先因为用户不是周期性的出现了，所以需要在每个用户的数据上加装地址信息以供接收端能够识别该信息应该传送给谁，扩大了开销</li>
<li>其次，因为每一个STDM帧中的时隙数量都<strong>小于</strong>连接在集中器上的用户数量，所以倘若所有的用户都是不间断地向集中器发送数据，则STDM将无法应付，内部的缓存一定会溢出</li>
</ol>
</li>
<li>
<p>波分复用(WDM，wavelength division multiplexing)<br>
实质就是光的频分复用。</p>
</li>
<li>
<p>码分复用：没懂....</p>
</li>
</ol>
<h2 id="五-数字传输系统">五. 数字传输系统</h2>
<p>主要讲广域网数据传输。略</p>
<table>
<thead>
<tr>
<th>既然介绍了复用技术的概念，那接下来就结合实际说说现实生活中的宽带是怎么使用复用技术的</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="六-带宽接入技术">六. 带宽接入技术</h2>
<p>带宽接入可以分为有线接入和无线接入，无线接入放在第9章<br>
而有线接入又可以分为3种方式</p>
<ol>
<li>
<p>非对称数字用户链路 ADSL<br>
电话信号的频带在300-3400Hz之间，但是电话线可以通过的频率实际上却超过1MHz，因此可以使用电话线，把原来没有利用的高频谱段留给用户上网使用。<br>
<img src="https://ArsenicX.github.io//post-images/1585315008062.png" alt="" loading="lazy"><br>
因为通常用户在上网时都是下载居多，上传较少，因此ADSL的下行带宽要远大于上行，“非对称”这个名词就是这么来的</p>
<p>采用方案：DMT技术。采用频分复用的方法，把40kHz以上一直到1.1MHz的高频谱划分为许多子信道，其中25个子信道用于上行信道，249个子信道用于下行信道<br>
<img src="https://ArsenicX.github.io//post-images/1587813910344.png" alt="" loading="lazy"></p>
<p>原理：<br>
<img src="https://ArsenicX.github.io//post-images/1587815528808.png" alt="" loading="lazy"><br>
<img src="https://ArsenicX.github.io//post-images/1587815533210.png" alt="" loading="lazy"><br>
以前，如图1，本地电话局一根线直接拉到家里面的电话机上<br>
现在，如图2，ISP-区域宽带接一根线并入到电话线（用户线）上，然后送到居民家中，再被分给电话用和电脑用<br>
但是怎么把网线并入电话线呢？然后又要怎么分离呢？这就需要<code>电话分离器</code>了，一个放在宽带和电话线合并的接口处用于网线的并入，另一个放在家中用于二者的分离<br>
同时由于宽带需要调制解调（原因见2.2.2），这就需要<code>ADSL调制解调器</code>了，分别放在电话分离器之前和之后使用</p>
<blockquote>
<p>原文：<img src="https://ArsenicX.github.io//post-images/1585357505659.png" alt="" loading="lazy"></p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>既然能走电话线上网，那就也能用电视线上网吧。</th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol start="2">
<li>
<p>光纤同轴混合网HFC (Hybrid Fiber Coax)：<br>
HFC网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。除了可传送电视节目外，还提供电话、数据和其他宽带交互型业务。</p>
<p>方案：现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造。</p>
<p>原理：HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，使用模拟光纤技术（在模拟光纤中采用光的振幅调制 AM，这比使用数字光纤更为经济）。模拟光纤从头端连接到光纤结点<br>
<img src="https://ArsenicX.github.io//post-images/1587815739186.png" alt="" loading="lazy"></p>
<p>为了要使现有的模拟电视机能接收数字电视信号，还需要一个<code>机顶盒</code>连接在同轴电缆和电视机之间<br>
为了用户能够利用HFC网接入到互联网以及在上行信道中传送交互数字电视所需的信息，还需要增加一个HFC 网的调制解调器，又称为<code>电缆调制解调器(cable modem)</code></p>
<p>但是，由图可对比看出，ADSL方案中，用户计算机连接的电话线是用户独享的，因此传输的最高数据率是确定的；而HFC方案中一个光纤结点连接着通常是500户人家，如果大量用户同时上网，则每个用户的实际速率则会降低的非常严重</p>
</li>
<li>
<p>FTTx技术<br>
现阶段上网体验最好的，一定是光纤到户FTTH(Fiber To The Home)，即把光纤直接拉到自己家独享，进门之后光信号才转化为电信号。<br>
但是这样势必使昂贵的，同时大多数用户也并不需要这么高的要求，因此便有了FTTx技术，而这个x是代表不同的光纤接入地点，比如FTTB（光纤到大楼，Building）、FTTC（光纤到路边，Curb） ...</p>
<p>原理：<img src="https://ArsenicX.github.io//post-images/1585366175213.png" alt="" loading="lazy"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>讲完信号在物理层面是怎么传输的之后，让我们着眼于数据链路层，看看信号是怎么传输给物理层的</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h1 id="三-数据链路层">三. 数据链路层</h1>
<p>首先要明白，数据链路层不关心物理层解决的问题，只关心帧头帧尾和校验。我们甚至还可以更简单地设想<br>
好像是沿者两个数据链路层之间的水平方向把帧直接发送到对方。<br>
<img src="https://ArsenicX.github.io//post-images/1585366258503.png" alt="" loading="lazy"><br>
在数据链路层中，使用的信道主要有两种类型：<strong>点对点信道</strong> 和 <strong>广播信道</strong></p>
<h2 id="一-点对点信道">一. 点对点信道</h2>
<ol>
<li>点对点信道的数据链路层在进行通信时的主要步骤如下：<br>
(1) 结点A的数据链路层把网络层交下来的IP数据报添加<strong>首部</strong>和<strong>尾部</strong>封装成<code>帧</code>。<br>
(2) 结点A把封装好的帧发送给结点B的数据链路层。<br>
(3) 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层：否则丢弃这个帧。<br>
<img src="https://ArsenicX.github.io//post-images/1585373759040.png" alt="" loading="lazy"></li>
<li>3个基本问题<br>
数据链路层的协议有许多种，但是有3个问题是基本的：
<ol>
<li>封装成帧(framing)<br>
在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<br>
首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限)。此外，首部和尾部还包括许多必要的控制信息。<br>
显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限一一一最大传送单元MTU<br>
<img src="https://ArsenicX.github.io//post-images/1587816353377.png" alt="" loading="lazy"><br>
其中控制字符SOH(StartOfHead)放在一帧的最前面，表示帧的首部开始。另一个控制字符(EndOfTransmission)表示帧的结束。<br>
请注意，SOH和EOT都是控制字符的名称。它们的十六进制编码分别是01（二进制是00000001）和04（二进制是00000100)，并不是SOHEOT这六个字母。<br>
<img src="https://ArsenicX.github.io//post-images/1585373814589.png" alt="" loading="lazy"><br>
当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。<br>
由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧〔只有首部廾始符SOH而没有传输结束符EOT),必须丢弃。而后面收到的数据有明确的帧定界符(SOH和EOT)，因此这是一个完整的帧，应当收下。</li>
<li>透明传输<br>
现在我们知道了开始符和结束符可以让就接收端识别一个完整的帧。但是，假如在数据中恰巧有一段数据就是00000100（EOT）呢？那这个时候就会被链路层错误的丢弃掉后面的数据。<br>
<img src="https://ArsenicX.github.io//post-images/1585373997129.png" alt="" loading="lazy"><br>
其解决方法就是使用转义字符“ESC”(其十六进制编码是 1B)，告诉接收端这个是数据，而不是标记符号<br>
<img src="https://ArsenicX.github.io//post-images/1585374097492.png" alt="" loading="lazy"></li>
<li>差错校验<br>
由于信噪比等客观原因，数据传输中一定会出现差错，0/1变成了1/0，这种差错称为<code>比特差错</code>。而现在广泛使用的是<code>循环冗余检验 CRC</code>的检错技术<br>
简单概括就是发送端生成<code>帧检验序列 FCS (Frame Check Sequence)</code>连接到原先的数据帧上，接收端接收到之后对【数据帧+FCS】作模2运算校验是否正确，从而决策是否接收。<br>
<img src="https://ArsenicX.github.io//post-images/1585375296590.png" alt="" loading="lazy"><br>
通过以上步骤可以近似认为：通过接收端数据链路层接受的<strong>帧</strong>均无差错<br>
注意：上面提到的差错均是比特差错，即在一个帧数据中数字发生了变化，可以用CRC查错；并不包括<code>传输差错</code>（例如发送了5个帧，却只收到了其中3个），传输差错在第五章讲解<br>
因此，通过了CRC，能实现无比特差错的传输，但是还不是可靠传输。</li>
</ol>
<blockquote>
<p>传输差错：假定发送[#1]-[#2]-[#3]<br>
帧丢失：收到[#1]-[#3]<br>
帧失序：收到[#1]-[#3]-[#2]<br>
帧重复：[#1]-[#2]-[#2]-[#3]</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>上面三种基本问题怎么解决呢？开端结尾标志定为多少呢？差错怎么校验呢？这就需要有协议来规定了</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="二-点对点协议-ppp">二. 点对点协议 PPP</h2>
<p>对于点对点的链路来说，PPP协议是目前使用最广泛的</p>
<ol>
<li>
<p>PPP的特点：（略写）</p>
<ul>
<li>被设计时应满足的需求：<br>
简单；封装成帧；透明性；多种网络层协议；多种类型链路；差错检验；检测连接状态；最大传送单元；网络层地址协商；数据压缩协商</li>
<li>PPP协议的组成部分：<br>
一个将IP数据报封装到串行链路的方法；一个用来建立、配置和测试数据链路连接的链路控制协议LCP(LinkControl Protocol)、一套网络控制协议NCP(NetworkControlProtocol)</li>
</ul>
</li>
<li>
<p>PPP协议的格式<br>
<img src="https://ArsenicX.github.io//post-images/1585380100279.png" alt="" loading="lazy"></p>
<ul>
<li>首部的第一个字段和尾部的第二个字段都是标志字段F(Flag)，7E的二进制为01111110，标志着一个帧的开始或者结束</li>
<li>首部中的地址字段和控制字段，即图中的A和C，暂时还没有具体定义，即没有任何信息量</li>
<li>首部的第四个字段是2字节的协议，不同的数有不同的含义。比如当协议字段为0x0021时PPP帧的信息字段为IP数据报；为0xC021时，信息字段是PPP链路控制协议LCPde数据</li>
<li>信息部份的长度不超过1500字节</li>
<li>尾部的第一个字段是使用CRC的帧检验序列FCS</li>
</ul>
<p>遇到数据字符和标志字符相同的情况下的解决方法：</p>
<ul>
<li>当PPP使用异步传输时，使用0x7D转义（字节填充法）：
<ul>
<li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。</li>
<li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。</li>
<li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li>
</ul>
</li>
<li>当PPP使用同步传输(一连串的比特发送)时，零比特填充法：
<ul>
<li>只要有连续的5个1，就填入一个0，使得确保不会出现6个0</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PPP协议的工作状态（没懂）：具体看书3.2.3</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>接下来是另外一种数据链路层的信道类型</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="三-广播信道这里的广播信道指的是同轴电缆或集线器并没有交换机">三. 广播信道（这里的广播信道，指的是同轴电缆或集线器，并没有交换机）</h2>
<blockquote>
<p>因为局域网使用的就是广播信道，而且目前局域网技术在计算机网络中占有重要的地位，所以我们着重学习局域网</p>
</blockquote>
<ol>
<li>
<p>局域网：<br>
局域网可按网络拓扑分为<strong>星形网</strong>、<strong>环形网</strong>、<strong>总线网</strong>。总线网以<strong>传统以太网</strong>最为著名。后二的各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。<br>
局域网可使用多种传输媒体。双绞线最便宜，已成为局域网中的主流传输媒体。而当数据率很高时，往往需要使用光纤作为传输媒体。<br>
<img src="https://ArsenicX.github.io//post-images/1585389989673.png" alt="" loading="lazy"><br>
在共享信道中要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：</p>
<ol>
<li>静态划分信道，如在第2章的2·4节中己经介绍过的频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高，不适合于局域网使用。</li>
<li>动态媒体接入控制，它又称为多点接入（multiple access)，其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：
<ul>
<li>随机接入：随机接入的特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突),使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li>
<li>受控接入：受控接入的特点是用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（polling），或称为轮询。</li>
</ul>
</li>
</ol>
<p>因为现在以太网几乎成为了局域网的同义词，同时由于<strong>受控接入</strong>目前在局域网中使用得较少<br>
所以我们重点讨论属于随机接入的传统以太网（传统指的是最早流行的10Mbit/s速率的以太网）</p>
</li>
</ol>
<h3 id="补充">补充：</h3>
<ul>
<li>
<p>以太网的两个标准：<br>
以太网有DIX Ethernet V2和IEEE 802.3 两个标准，但是差别很小。<br>
而后因为种种原因，标准委员会也没有统一标准，反而还被迫制定了好几种标准。但是为了不同的标准也能适配，委员会将数据链路层分为了2层：<code>逻辑链路控制LLC(Logical Link Control)</code>子层和<code>媒体接入控制MAC(Medium Access Control)</code>子层，其中，与接入到传输媒体有关的内容都放在MAC子层上，而LLC子层与传输媒体无关<br>
<img src="https://ArsenicX.github.io//post-images/1585409955296.png" alt="" loading="lazy"><br>
随着局域网市场的发展，DIX标准被越来越多的使用，IEEE已不再被使用。也正因如此，适配IEEE标准的LLC子层作用就不大了。现如今很多厂商生产适配器时都甚至不会再装LLC协议了</p>
</li>
<li>
<p>适配器的作用：<br>
适配器本来是在主机箱内插入的一块网络接口板（或者是在笔记本电脑中插入一块PCMCIA卡一一个人计算机存储器卡接口适配器）。这种接口板又称为网络接囗卡NIC(NetworkinterfaceCard)或简称为<code>网卡</code>。这种通信适配器上面装有处理器和存储器（包括RAM和ROM)。</p>
<p>简单来讲，计算机与外界局域网的连接就是通过通信适配器（adapt）进行的。<br>
适配器和局域网之间的通信是通过电缆或双绞线以<strong>串行传输</strong>方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的I/O总线以<strong>并行传输</strong>方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。同时由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p>
<p>注意，计算机的硬件地址就在适配器的ROM中，而计算机的软件地址一一IP地址则在计算机的存储器中。<br>
<img src="https://ArsenicX.github.io//post-images/1585410048907.png" alt="" loading="lazy"></p>
</li>
</ul>
<ol>
<li>
<p>CSMA/CD 协议<br>
为了通讯的便捷，以太网采用了两种措施：</p>
<ol>
<li>较为灵活的无连接的工作方式。即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编号，也不要求对方发回确认。即不可靠的交付。类似于傻大个，拿到信息就对外喊，自己喊的是什么也不管，别人听没听到也不管</li>
<li>使用曼彻斯特(Manchester)编码。二进制基带数字信号通常就是高、低电压交替出现的信号，使用这种信号的最大问题就是出现一长串的连1或连0时，接收端就无法从收到的比特流中提取位同步（即比特同步）信号。<br>
而曼彻斯特编码的编码方法是把每一个码元再分成两个相等的间隔。码元1是前一个间隔为低电压面后一个间隔为高电压，码元0则正好相反，从高电压变到低电压（也可采用相反的约定，即1是“前高后低”而0是“前低后高“。这样就保证了在每一个码元的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来。<br>
但是从曼彻斯特编码的波形图也不难看出其缺点，这就是它所占的频带宽度比原始的基带信号增加了一倍（区为每秒传送的码元数加倍了）</li>
</ol>
<table>
<thead>
<tr>
<th>关于第一点，这就有隐患了。如果同时两个傻大个喊了话，那准备接受的人就会听到两个声音，接收人就不能准确的提取出有效信息，那这怎么办呢？（注意这里仅仅考虑同时喊话导致第三人听不清楚的隐患，而不考虑喊错了话或者是喊漏了话，因为这些情况会被上层运输层发现，后续补救由他们负责）这时候就用到了 CSMA/CD 协议（载波监听多点接入/碰撞检测）</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>CSMA/CD 协议要点：</p>
<ul>
<li>多点接入：表示许多计算机以多点接入的方式连接在一根总线上。（这个是废话）</li>
<li>载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</li>
<li>碰撞检测：就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li>
</ul>
<p>我们记<strong>单程 端到端</strong>的传播时延为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>，可以得知，<strong>最迟</strong>要经过 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> 才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。（不明白为啥的话可以看下图）<br>
<img src="https://ArsenicX.github.io//post-images/1587817663080.png" alt="" loading="lazy"><br>
由此可见，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网的这一特点称为<strong>发送的不确定性</strong>。以太网的端到端往返时间 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> 称为<strong>争用期(contention period)</strong>，又称为<strong>碰撞窗囗（collision window)</strong>。只有通过争用期的“考验”，即经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。这时才可以放心把这一帧数据顺利发送完毕。<br>
tips: 电磁波在 1km 电缆的传播时延为 5μs（应当记住）</p>
<p>协议规定，如果两个傻大个在喊话过程中听到了别人在讲话，也就说明发生了碰撞，那两个人就先都别再喊话了，冲突的站点都等一段时间之后再发数据</p>
<table>
<thead>
<tr>
<th>那等多久呢？</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><img src="https://ArsenicX.github.io//post-images/1585413575106.png" alt="" loading="lazy"><br>
<img src="https://ArsenicX.github.io//post-images/1585411897837.png" alt="" loading="lazy"></p>
<p>目前为止，整个流程就是，若有两个人在喊话，喊得过程中他们发现还有其他人也在喊话（边发送边监听信道），那这时两个人就同时停下来，等随机时间之后再喊。</p>
<table>
<thead>
<tr>
<th>那就又有个问题了，假如我喊的话很少，以至于我喊完了也没有听到别人在喊，这时候我就会认为自己已经完成传输了。即使确实发生了碰撞，但碰撞传来的时候我已经喊完了，我的监听信道早已经关闭了，听不到了。不知道发生了碰撞，我也就不会重传发生冲突的帧了，这可咋办？</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>为了解决这个问题，以太网规定最短帧长为64字节，即512bit。如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。<br>
tips:  对于10Mbit/s以太网，发送512bit的时间需要51.2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>s，也就是上面提到的争用期。<br><br>
由此可见，以太网在发送数据时，如果在争用期（共发送了64字节）没有发生碰撞，那么后续发送的数据就一定不会发生冲突。<br>
也因此可以得出，如果发生碰撞，则这时己经发送出去的数据最多最多也就是64字节。因此，<strong>凡长度小于字节的帧都是由于冲突而异常中止的无效帧</strong>，只要收到了这种无效帧，就应当立即将其丢弃。</p>
<p>以下还有几个小的知识点：</p>
<ol>
<li><strong>强化碰撞</strong>的概念。这就是当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送32比特或48比特的<strong>人为干扰信号</strong><br>
<img src="https://ArsenicX.github.io//post-images/1587818584372.png" alt="" loading="lazy"><br>
从图可以看出，A站从发送数据开始到发现碰撞并停止发送的时间间隔是T<sub>B</sub>。A站得知碰撞己经发生时所发送的强化碰撞的干扰信号的持续时间是T<sub>J</sub>。B站在得知发生碰撞后，也要发送人为干扰信号，但为简单起见，图没有画出B站所发送的人为干扰信号。发生碰撞使A浪费时间是 T<sub>B</sub>+T<sub>J</sub> ，可是整个信道被占用的时间还要增加一个单程端到端的传播时延<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>，因此总线被占用的时间是T<sub>B</sub>+T<sub>J</sub>+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>。</li>
<li>以太网还规定了<strong>帧间最小间隔</strong>为 9.6<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>s，相当于96比特时间。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</li>
<li>当然显然，使用CSMA/CD 协议时，一个站不可能同时进行发送和接收（但必须边发送边监听信道）。因此使用CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工通信)。</li>
</ol>
<p><strong>根据以上所讨论的，可以把CSMA/CD协议的要点归纳如下：</strong></p>
<ol>
<li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部（见后面的3.4.3节），组成以太网帧，放入适配器的缓存中。但在发送之前，必须先检测信道。</li>
<li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。</li>
<li>在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性：
<ul>
<li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到（1)。</li>
<li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍512比特时间后，返回到步骤（2），继续检测信道。但若重传达16次仍不能成功，则停止重传而向上报错。</li>
</ul>
</li>
</ol>
<p>以太网每发送完一帧，一定要把己发送的幀暂时保留一下。如果在争用期内检出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。</p>
</li>
<li>
<p>使用集线器的星形拓扑（略）</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>通过上面的要点归纳，能得知，如果信道一直忙碌，那主机就要一直不停的检测；如果好不容易能发了，又产生了冲突，得，又得重发，重发前还要先等一会。这也太不靠谱了。我们先看看怎么计算他有多不靠谱</th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol start="4">
<li>信道利用率<br>
<img src="https://ArsenicX.github.io//post-images/1587820737211.png" alt="" loading="lazy"><br>
我们可以注意到，成功发送一个帧的时间为 T<sub>0</sub> + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>，而想要提高以太网的信道利用率，就必须减小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> ，或者说减少其与 T<sub>0</sub> 之比。<br>
在以太网中定义了参数 a，它是以太网单程端到端时延<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> 与帧的发送时间 T<sub>0</sub> 之比：a = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> / T<sub>0</sub><br>
可得出：</li>
</ol>
<ul>
<li>a越小，表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。</li>
<li>a越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。<br>
<br>而表现在上式中，就是：</li>
<li>当数据率一定时，以太网的连线的长度受到限制，否则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>的数值会太大。</li>
<li>同时以太网的帧长不能太短，否则 T<sub>0</sub> 的值会太小，使 a 值太大。<br>
<br>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是<strong>CSMA/CD</strong>，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。<br>
发送一帧占用线路的时间是 T<sub>0</sub> + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>，而帧本身的发送时间是T<sub>0</sub>。于是我们可计算出理想情况下的极限信道利用率 S<sub>max</sub>为： <img src="https://ArsenicX.github.io//post-images/1587827482164.png" alt="" loading="lazy"><br>
这个式子的意义是：<br>
虽然实际的以太网不可能有这样高的极限信道利用率，但该式指出了只有当参数a远小于1才能得到尽可能高的极限信道利用率。<br>
反之，若参数a远大于1，（即每发生一次碰撞，就要浪费相对较多的传输数据的时间），则极限信道利用率就远小于1，而这时实际的信道利用率就更小了。<br>
据统计，当以太网的利用率达到30%时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</li>
</ul>
<table>
<thead>
<tr>
<th>上面主要讲了链路层的信道类型和相关协议，那有了规范话的数据后就要开始发送。但是我要发给谁呢？怎么唯一确定接收目标呢？</th>
</tr>
</thead>
<tbody></tbody>
</table>
<ol start="5">
<li>
<p>以太网的 MAC 层</p>
<ol>
<li>MAC 层的硬件地址</li>
</ol>
<table>
<thead>
<tr>
<th>先回答上面的问题，能够确定【你发出的数据是该由谁接受】的标准就是MAC地址，又称硬件地址、物理地址。</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>这个MAC地址是在出厂时被嵌入到适配器ROM中的，再之后被安装到计算机中后，该计算机就有了唯一的MAC地址。当然，如果一台计算机安装多个适配器，那他就会有多个MAC地址<br>
<br>这个MAC地址目前是IEEE 802标准为局域网规定了一种6字节（48位）的全球地址。<br>
现在IEEE的注册管理机构RA（ Registration Authority）是局域网全球地址的法定管理机构【 W-IEEERA】，它负责分配地址字段的<strong>6个字节中的前三个字节（即高位24位）</strong>。世界上凡要生产局域网适配器的厂家都必须<strong>向IEEE购买</strong>由这三个字节构成的这个号（即地址块），这个号的正式名称是<strong>组织唯一标识符OUI</strong>（ Organizationally Unique Identifier）。地址字段中的后三个字节（即低位24位）则<strong>由厂家自行指派</strong>，称为<strong>扩展标识符</strong>（ extended identifier），只要自行保证生产出的适配器没有重复地址即可。<br><br>
不过，IEEE还考虑到可能有人并不愿意向IEEE的RA购买OUI。为此，IEEE把地址字段第1字节的最低第二位规定为G位，表示 Global/ Local。当GL位为0时是<strong>全球管理</strong>，保证在全球没有相同的地址，厂商向IEE购买的OUI都属于全球管理。当地址字段的G/L位为1时是<strong>本地管理</strong>，这时用户可任意分配网络上的地址。采用2字节地址字段时全都是本地管理。但应当指出，以太网几乎不理会这个G/L位。</p>
<table>
<thead>
<tr>
<th>好的，我现在知道怎么把全球这么多的主机唯一确定了，可是当主机收到信号时，他怎么知道是给他发的呢？</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>适配器是有过滤功能的。适配器从网络上每收到一个MAC帧就先用硬件检査MAC帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站的帧”包括以下三种帧：</p>
<ol>
<li>单播（unicast）帧（一对一），即收到的帧的MAC地址与本站的硬件地址相同</li>
<li>广播（ broadcast帧（一对全体），即发送给本局域网上所有站点的帧（MAC帧上目标地址全1）</li>
<li>多播（ multicast）帧（一对多），即发送给本局域网上一部分站点的帧</li>
</ol>
<blockquote>
<p>以太网适配器还可设置为一种特殊的工作方式，即混杂方式（ promiscuous mode）。工作在混杂方式的适配器只要“听到”有帧在以太网上传输就都悄悄地接收下来，而不管这些帧是发往哪个站。请注意，这样做实际上是<strong>窃听</strong>其他站点的通信而并不中断其他站点的通信。网络上的黑客（ hacker或 cracker）常利用这种方法非法获取网上用户的口令。因此，以太网上的用户不愿意网络上有工作在混杂方式的适配器<br>
但混杂方式有时却非常有用。例如，网络维护和管理人员需要用这种方式来监视和分析以太网上的流量，以便找出提高网络性能的具体措施。有一种很有用的网络工具叫做嗅探器（ Sniffer〕就使用了设置为混杂方式的网络适配器。此外，这种嗅探器还可帮助学习网络的人员更好地理解各种网络协议的工作原理。<br>
因此，混杂方式就像一把双刃剑，是利是弊要看你怎样使用它。技术无罪</p>
</blockquote>
<p>IEEE规定地址字段的第一字节的最低位为G位。IG表示 Individual/ Group。当IG位为0时，地址字段表示一个单个站地址。当IG位为1时表示组地址，用来进行多播。</p>
<table>
<thead>
<tr>
<th>总结</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>上文中我们说到，MAC地址地段中的前3个字节是由IEEE分配的组织唯一标识符OUI，后3个字节是由厂家自行分配。<br>
而到目前我们已经认识到，由IEEE分配的的址字段前三个字节中，第一个字节的最后一位为 I/G 位，而第二个字节为 G/L位，能够剩余分配的只有22位，即总共唯一表示每个适配器的只有46（22+24）位。不过2<sup>46</sup>已经超过了70万亿，所以目前还不用担心地址耗尽的问题<br>
用这种方式得到的48位地址称为EUI-48，这里EUI表示扩展的唯一标识符（ Extended Unique Identifier）。</p>
<ol start="2">
<li>MAC帧的格式<br>
从“以太网的两个标准”那节我们知道MAC帧有两种标准，但是我们这里只介绍使用的最多的V2标准（虽然IEEE标准下制定的LLC层已近乎淘汰，V2标准已成为主流，但是人们还是习惯称其为IEEE下的MAC标准）<br>
以太网V2的MAC帧较为简单，由五个字段组成。
<ul>
<li>
<p>前两个字段分别为6字节长的目的地址和源地址字段。</p>
</li>
<li>
<p>第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。例如，当类型字段的值是0x0800时，就表示上层使用的是IP数据报。若类型字段的值为0x8137，则表示该帧是由 novell IPX发过来的。</p>
</li>
<li>
<p>第四个字段是数据字段，其长度在46到1500字节之间（46字节是这样得出的：最小长度64字节减去18字节的首部和尾部就得出数据字段的最小长度）。</p>
</li>
<li>
<p>最后一个字段是4字节的帧检验序列FCS（使用CRC检验）。当传输媒体的误码率为1×108时，MAC子层可使未检测到的差错小于1×1014。</p>
</li>
<li>
<p>从上图可看出，在传输媒体上实际传送的要比MAC帧还多8个字节。这是因为当个站在刚开始接收MAC帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此MAC帧的最前面的若干位就无法接收，结果使整个的MAC成为无用的帧。<br>  为了接收端迅速实现位同步，从MAC子层向下传到物理层时还要在帧的前面插入8字节（由硬件生成），它由两个字段构成。</p>
<ul>
<li>第一个字段是7个字节的前同步码（1和0交替码），它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率（时钟频率就是发送数据的速度），使它和发送端的时钟同步，也就是“实现位同步”（位同步就是比特同步的意思）。</li>
<li>第二个字段是帧开始定界符，定义为l0101011.它的前六位的作用和前同步码一样，最后的两个连续的1就是告诉接收端适配器：“MAC帧的信息马上就要来了，请适配器注意接收”。<br>在以太网上传送数据时是以帧为单位传送的。以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧。可见以太网<strong>不需要使用帧结束定界符</strong>，也不需要使用字节插入来保证透明传输。</li>
</ul>
<p>注意: MAC帧的FCS字段的检验范围并不包括前同步码和帧开始定界符。而且，在使用 SONET/SDH进行同步传输时则不需要用前同步码，因为在同步传输时收发双方的位同步总是一直保持着的。</p>
</li>
</ul>
</li>
</ol>
<p>这里我们要指出，在以太网V2的MAC帧格式中，其首部并没有一个帧长度（或数据长度）字段。那么，MAC子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？我们在前面讲述曼彻斯特编码时已经讲过，在曼彻斯特编码的每一个码元（不管码元是1或0）的正中间一定有一次电压的转换（从高到低或从低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了（既不发送1，也不发送0）。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数4字节（FCS字段长度是4字节），就能确定数据字段的结束位置。</p>
<p>当数据字段的长度小于46字节时，MAC子层就会在数据字段的后面加入一个整数字节的填充字段，以保证以太网的MAC帧长不小于64字节。我们应当注意到，MAC帧的首部并没有指出数据字段的长度是多少。在有填充字段的情况下，接收端的MAC子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。现在的问题是：上层协议如何知道填充字段的长度呢？（IP层应当丢弃没有用处的填充字段。）可见，上层协议必须具有别有效的数据字段长度的功能。在后面章节我们将会学到，当上层使用IP协议时，其首部就有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于MAC帧数据字段的长度。例如，当IP数据报的总长度为42字节时，填充字段共有4字节。当MAC帧把46字节的数据上交给I层后，IP层就把其中最后4字节的填充字段丢弃。</p>
<table>
<thead>
<tr>
<th>后续</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>IEEE8023标准规定凡出现下列情况之一的即为无效的MAC帧：<br>
（1）帧的长度不是整数个字节；<br>
（2）用收到的帧检验序列FCS查出有差错；<br>
（3）收到的帧的MAC客户数据字段的长度不在46-1500字节之间。考虑到MAC帧首部和尾部的长度共有18字节，可以得出有效的MAC帧长度为64-1518字节之间。<br>
对于检查出的无效MAC帧就简单地丢弃。以太网不负责重传丢弃的帧。</p>
</li>
</ol>
<p>拓展的以太网</p>
<table>
<thead>
<tr>
<th>网络，顾名思义，是有许多主机连在一起的；我们学习了数据是怎么在这么多主机之间通讯的，但是这么多主机是如何连起来的呢？</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="四-拓展以太网">四. 拓展以太网</h2>
<h3 id="一-在物理层面拓展">一. 在物理层面拓展</h3>
<p>在以前，可以使用转发器进行拓展，但随着双绞线以太网成为以太网的主流类型，扩展以太网的覆盖范围已很少使用转发器了。<br>
现在，扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对光纤）和一对光纤调制解调器。光纤调制解调器的作用是进行电信号和光信号的转换。由于光纤带来的时延很小并且带宽很宽，因此使用这种方法可以很容易地使主机和几公里以外的集线器相连接。<br>
<img src="https://ArsenicX.github.io//post-images/1587883488216.png" alt="" loading="lazy"><br>
也可以使用多个集线器，连接成覆盖更大范围的多级星形结构的以太网。如图所示。<br>
<img src="https://ArsenicX.github.io//post-images/1587884753458.png" alt="" loading="lazy"><br>
显然，现在不仅拓展了以太网的覆盖范围，同时也使得不是同一个系的主机能够互相连接<br>
但是这也带来了一些缺点：</p>
<ol>
<li>在互连之前，每个集线器连接的网络是一个独立的碰撞域（或称为冲突域），即在任一时刻，在每一个碰撞域中只能有一个站在发送数据。若每一个系的以太网的最大吞吐量是10 Mbit/s，则三个系总的最大吞吐量共有30Mbis。而当三个系的以太网通过集线器互连起来后就把三个碰撞域变成一个碰撞域（范围扩大到三个系），而这时的最大吞吐量仍然是一个系的吞吐量10Mbis。这就是说，当某个系的两个站在通信时所传送的数据会通过所有的集线器进行转发，使得其他系的内部在这时都不能通信（一发送数据就会碰撞）。</li>
<li>如果不同的系使用不同的以太网技术（如数据率不同），那么就不可能用集线器将它们互连起来。假设一个系使用10 Mbit/s的适配器，而另外两个系使用10/100Mbts的适配器，那么用集线器连接起来后，大家都只能工作在10Mbis的速率。<br>
集线器基本上是个多接口（即多端口）的转发器，它并不能把帧进行缓存。<br>
|要怎么解决这个问题呢？这里先按下不表，先看从数据链路层进行以太网的拓展|<br>
|-|</li>
</ol>
<h3 id="二-在数据链路层拓展">二. 在数据链路层拓展</h3>
<p>扩展以太网更常用的方法是在数据链路层进行。最初人们使用的是网桥（ bridge）。网桥对收到的帧根据其MAC帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是根据此帧的目的MAC地址，查找网桥中的地址表，然后确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）</p>
<p>随后由于网桥的接口数量少，而且数据传输速度慢，1990年问世的交换式集线器（ switching hub），很快就淘汰了网桥。交换式集线器常称为以太网交换机（ switch或第二层交换机（L2 switch），强调这种交换机工作在数据链路层。</p>
<ol>
<li>
<p>以太网交换机的特点</p>
<ol>
<li>以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口，并且一般都工作在<strong>全双工方式</strong>。以太网交换机还具有<strong>并行性</strong>，即能同时连通多对接口，使多对主机能同时通信（而网桥只能一次分析和转发一个帧）。相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong>。</li>
</ol>
<blockquote>
<p>对于传统的10Mbts的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbis。若使用以太网交换机来连接这些主机，虽然在每个接口到主机的带宽还是10 Mbit/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有10个接口的交换机的总容量则为100Mbis。这正是交换机的最大优点。</p>
</blockquote>
<ol start="2">
<li>以太网交换机的<strong>接口还有存储器</strong>，能在输出端口繁忙时把到来的帧进行缓存。因此，如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的接口繁忙时，发送帧的这两台主机的接口会把收到的帧暂存一下，以后再发送出去。</li>
</ol>
<blockquote>
<p>虽然许多以太网交换机对收到的帧采用存储转发方式进行转发，但也有一些交换机采用直通（ cut-through）的交换方式。直通交换不必把整个数据帧先缓存后再进行处理，而是在接收数据帧的同时就立即按数据帧的目的MAC地址决定该帧的转发接口，因而提高了帧的转发速度。<br>
如果在这种交换机的内部采用基于硬件的交叉矩阵，交换时延就非常小。<br>
直通交换的一个缺点是它不检査差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线路速率匹配、协议转换或差错检测时。现在有的厂商已生产出能支持两种交换方式的以太网交换机。</p>
</blockquote>
<ol start="3">
<li>以太网交换机是一种<strong>即插即用</strong>设备，其内部的帧交换表（又称为地址表）是通过<strong>自学习算法</strong>自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多</li>
</ol>
<blockquote>
<p>从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要作任何改动。自学习下面介绍</p>
</blockquote>
<p>因此以太网交换机的性能远远超过普通的集线器，而且价格并不贵，这不仅使普通的网桥被淘汰，也使工作在物理层的集线器逐渐地退出了市场<br>
现在我们的传输方式已经没有了之前缺点（俩傻大个不能同时喊话，碰撞了还要傻等一会），也就说明不必再使用 CSMA/CD协议了，那为什么还叫以太网呢？这是因为我们传输的数据帧结构未变，依然还是以太网的帧结构</p>
</li>
<li>
<p>自学习功能</p>
<blockquote>
<p>全篇引用教材，没啥好说的：<br>
<img src="https://ArsenicX.github.io//post-images/1587888656376.png" alt="" loading="lazy"><br>
<img src="https://ArsenicX.github.io//post-images/1587888677321.png" alt="" loading="lazy"></p>
</blockquote>
</li>
</ol>
<h3 id="三-虚拟局域网-vlan">三. 虚拟局域网 VLAN</h3>
<p>从名称就可以大概理解，实际意义上的局域网应该是在一个集线器/交换机 网络中的，而虚拟局域网就是使得，物理层面不属于同一局域网的设备，可以通过虚拟的方式是他们连接在一起<br>
虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。<br>
<img src="https://ArsenicX.github.io//post-images/1587889975423.png" alt="" loading="lazy"><br>
从图中可看出，每一个VLAN内的计算机可处在不同的局域网中，甚至可以不在同一层楼中。<br>
利用以太网交换机可以很方便地将这10台计算机划分为三个虚拟局域网：VLAN1， VLAN2和VLAN3.在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员所发出的广播。</p>
<blockquote>
<p>例如，计算机B1~B3同属于虚拟局域网VLAN2.当B1向工作组内成员发送数据时，计算机B2和B3将会收到广播的信息，虽然它们没有和B1连在同一个以太网交换机上；而计算机A1，A2和C1都不会收到B1发出的广播信息，虽然它们都与B1连接在同一个以太网交换机上。以太网交换机不向虚拟局域网以外的计算机传送B1的广播信息。</p>
</blockquote>
<table>
<thead>
<tr>
<th>看到这里可能就有些疑惑其中的一句话了：<strong>以太网交换机不向虚拟局域网以外的计算机传送B1的广播信息</strong>。这是什么意思？简单来说就是现在整个A系列都不能和B、C连接了。接下来我再阐述一下</th>
</tr>
</thead>
<tbody></tbody>
</table>
<blockquote>
<p>借鉴参考了<a href="https://zhuanlan.zhihu.com/p/35616289">知乎文章</a><br>
在没有划分VLAN时，1号机每发一次广播帧，都会被交换机转发给全部其他主机（强调广播，是因为普通的单对单消息会被交换机处理，不转发给非目标主机）<br>
<img src="https://ArsenicX.github.io//post-images/1587890744660.jpg" alt="" loading="lazy"><br>
而当设置了VLAN后，再发送广播帧就只会发送到同一局域网下<br>
<img src="https://ArsenicX.github.io//post-images/1587891104475.jpg" alt="" loading="lazy"><br>
在计算机和交换机中，其实际的效果和两个交换机无异<br>
<img src="https://ArsenicX.github.io//post-images/1587891158513.jpg" alt="" loading="lazy"><br>
从上图中看出，由于12号机和34号机已经处在了不同的网络中（虽然物理上是同一网络，但是逻辑上不在一起），所以如果不加处理，1/2将不能和3/4进行通信<br>
明明接在同一台交换机上，但却偏偏无法通信——这个事实也许让人难以接受。但它既是VLAN方便易用的特征，又是使VLAN令人难以理解的原因。</p>
</blockquote>
<p>这样，虚拟局域网限制了接收广播信息的计算机数，使得网络不会因传播过多的广播信息（即所谓的“广播风暴”）而引起性能恶化。</p>
<table>
<thead>
<tr>
<th>那怎么辨别这条消息是来自与那个VLAN的呢？</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>1988年IEEE批准了802.3ac标准，这个标准定义了以太网的帧格式的扩展，以便支持虚拟局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标记（tag），用来指明发送该帧的计算机属于哪一个虚拟局域网。插入VLAN标记得出的帧称为802.1Q帧。显然，如果还使用原来的以太网帧格式，那么就无法区分是否划分了虚拟局域网。<br>
<img src="https://ArsenicX.github.io//post-images/1587891924095.png" alt="" loading="lazy"><br>
VLAN标记字段的长度是4字节，插入在以太网MAC帧的源地址字段和类型字段之间。VLAN标记的前两个字节总是设置为0x8100（即二进制的10000010000，称为IEEE802.1Q标记类型。<br>
当数据链路层检测到MAC帧的源地址字段后面的两个字节的值是0x8100时，就知道现在插入了4字节的VLAN标记。于是就接着检查后面两个字节的内容。在后面的两个字节中，前3位是用户优先级字段，接着的一位是规范格式指示符CFI（ Canonical format Indicator）°，最后的12位是该虚拟局域网vLAN标识符vID（ VLAN ID），它唯一地标志了这个以太网帧属于哪一个VLAN。<br>
由于用于VLAN的以太网帧的首部增加了4个字节，因此以太网的最大帧长从原来的1518字节（1500字节的数据加上18字节的首部）变为1522字节。</p>
<h2 id="五-高速以太网">五. 高速以太网</h2>
<blockquote>
<p>这章主要简单介绍了几种高速以太网的技术，略去<br>
现在只简要谈谈以太网宽带接入的技术（摘自课本）：<br><br>
现在人们也在使用以太网进行宽带接入互联网。为此，IEE在2001年初成立了8023EFM工作组，专门研究高速以太网的宽带接入技术问题<br>
以太网接入的一个重要特点是它可以提供双向的宽带通信，并且可以根据用户对带宽的需求灵活地进行带宽升级（例如，把10兆的以太网交换机更新为吉比特的以太网交换机）。当城域网和广域网都采用吉比特以太网或10吉比特以太网时，采用以太网接入可以实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率且降低了传输的成本。<br>
然而以太网的帧格式标准中，在地址字段部分并没有用户名字段，也没有让用户键入密码来鉴别用户身份的过程。如果网络运营商要利用以太网接入到互联网，就必须解决这个问题。<br>
于是有人就想法子把数据链路层的两个成功的协议结合起来，即把PP协议中的PPP帧再封装到以太网中来传输。这就是1999年公布的PPPoE（ PPP over ethernet），意思是“在以太网上运行PPP”【RFC2516】。现在的光纤宽带接入FTTx都要使用 PPPOE的方式进行接入。<br>
例如，如果使用光纤到大楼FTTB的方案，就在每个大楼的楼口安装一个光网络单元ONU（实际上就是一个以太网交换机），然后根据用户所申请的带宽，用5类线（请注意到这个地方，传输媒体已经变为铜线了）接到用户家中。如果大楼里上网的用户很多，那么还可以在每一个楼层再安装一个100Mbis的以太网交换机。各大楼的以太网交换机通过光缆汇接到光结点汇接点（光汇接点一般通过城域网连接到互联网的主干网）。<br>
使用这种方式接入到互联网时，在用户家中不再需要使用任何调制解调器。用户家中只有一个RJ-45的插口。用户把自己的个人电脑通过5类网线连接到墙上的RJ-45插口中，然后在 PPPOE弹出的窗口中键入在网络运营商处购买的用户名（就是一串数字）和密码，就可以进行宽带上网了。请注意，使用这种以太网宽带接入时，从用户家中的个人电脑到户外的第一个以太网交换机的带宽是能够得到保证的。因为这个带宽是用户独占的，没有和其他用户共享。但这个以太网交换机到上一级的交换机的带宽，是许多用户共享的。因此，如果过多的用户同时上网，则有可能使每一个用户实际上享受到的带宽减少。这时，网络运营商就应当及时进行扩容，以保证用户的利益不受损伤。<br>
顺便指出，当用户利用ADSL（非对称数字用户线）进行宽带上网时，从用户个人电脑到家中的ADSL调制解调器之间，也是使用RJ45和5类线（即以太网使用的网线）进行连接的，并且也是使用PPoE弹出的窗口进行拨号连接的。但是用户个人电脑发送的以太网帧到了家里的ADSL调制解调器后，就转换成为ADSL使用的PPP帧。需要注意的是，在用户家中墙上是通过电话使用的RJ-l1插口，用普通的电话线传送PPP帧。这已经和以太网没有关系了。所以这种上网方式不能称为以太网上网，而是利用电话线宽带接入到互联网。</p>
</blockquote>
<h1 id="四-网络层">四. 网络层</h1>
<h2 id="一-两种服务">一. 两种服务</h2>
<p>在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ 这个问题曾引起了长期的争论。<br>
有人认为应该借助电话线的思路，先建立一条可靠连接然后再发送数据，这种连接服务也被称为“虚电路服务”；但是也有人认为，计算机比电话要更复杂也更智能，也具有差错处理能力，所有没有必要先建立可靠的连接之后才传送数据，事先先建立可靠的连接会增加额外开销<br>
<img src="https://ArsenicX.github.io//post-images/1587893487466.png" alt="" loading="lazy"><br>
<img src="https://ArsenicX.github.io//post-images/1587893504434.png" alt="" loading="lazy"><br>
因此后来互联网的设计思路就变成了这样的：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。{尽最大努力，即传输过程中可能会出现丢失、重复等问题，但我尽力而为）<br>
如今互联网发展到这个规模，也充分证明当时采用这个思路的正确<br>
<img src="https://ArsenicX.github.io//post-images/1587893617139.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>每层都有对应的协议，网络层也不例外</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="二-网际协议ip">二. 网际协议IP</h2>
<p>网际协议IP是TCP/P体系中两个最主要的协议之一，也是最重要的互联网标准协议之一。严格来说，这里所讲的IP其实是IP的第4个版本，应记为IPv4，但在讲述IP协议的各种原理时，往往不在IP后面加上版本号。在后面也会介绍较新的版本IPv6（版本1~3和版本5都未曾使用过）<br>
与IP协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议ARP（ Address resolution protocol）</li>
<li>网际控制报文协议ICMP（ Internet Control Message Protocol）</li>
<li>网际组管理协议IGMP（ nternet Group Management Protocol）</li>
</ul>
<p>本来还有一个协议叫做逆地址解析协议RARP（ Reverse address resolution protocol），是和ARP协议配合使用的。但现在已被淘汰不使用了。<br>
<img src="https://ArsenicX.github.io//post-images/1587895336725.png" alt="" loading="lazy"><br>
上图画出了这三个协议和网际协议IP的关系。在这一层中，ARP画在最下面，因为IP经常要使用这个协议。ICMP和GMP画在这一层的上部，因为它们要使用I协议。这三个协议将在后面陆续介绍。</p>
<h3 id="一-虚拟互连网络">一. 虚拟互连网络</h3>
<p>网络是互连的，我们想让所有人的计算机都可以连接在一起<br>
那能不能让所有人都是用同一种网络呢？显然不行，每个用户的需求都不一样，没有一种单一的网络能够适应所有用户的需求。<br>
那就需要找一个中间设备将网络互相连接起来。而我们目前接触过的转发器（物理层）和网桥&amp;交换机（数据链路层），他们都只是把网络扩大了，还是一个网络，不是真正意义上的网络连接<br>
能够实现连接网络的设备，就是路由器。路由器其实就是一台专用计算机，用来互联网中进行路由选择的。（路由器在许多文献中也被称为网关）<br>
<img src="https://ArsenicX.github.io//post-images/1587896091654.png" alt="" loading="lazy"><br>
因为每个通过路由器连接在一起的网络，都要遵从路由器的网际协议IP协议，因此这些连接在一起的网络也可以被看作一个更大的虚拟互连网络。这些被连接起来的网络，在网络层层面，就好像成为了一个统一的网络。照着这个思想，在全球的IP网络上继续使用传输层的TCP协议，就成为了互联网 Internet<br>
<img src="https://ArsenicX.github.io//post-images/1587896335603.png" alt="" loading="lazy"><br>
在由各种异构网络组成的互联网中，主机间的数据传送就可以看为<br>
<img src="https://ArsenicX.github.io//post-images/1587897434418.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>之前我们讲到，怎么确定我们发送的数据应该发给谁时，我们用到了MAC地址，在交换机中有存放的MAC地址的表。但是，我们现在上升到了网络层，已经不是一个网络内了（上面的内容也能看出来交换机和路由器已经是两个级别了）。那现在又要怎么区分每台主机呢？首先，不同的联网主机所使用的硬件地址不一定一样，所以统一硬件码是不可能的；其次，一个交换机连接的主机数量不是太多所以可以把所有主机的MAC写入交换机，但把全球所有主机的MAC都写进路由器也不可能，因此我们决定统一IP网络地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>###二. 分类IP地址<br>
这里我们用到的解决方法就是使用IP地址。IP 地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。</p>
<ol>
<li>IP地址及其表示<br>
而标题所谓的分类IP地址，就是将IP地址也根据不同情况分为好多种。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）。<br>
两级的 IP 地址可以记为：IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt;} （ ::= 代表“定义为”）</li>
</ol>
<p>对主机或路由器来说，IP地址都是32位的二进制代码。为了提高可读性，我们常常把32位的IP地址中的每8位插入一个空格（但在机器中并没有这样的空格）。又为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做点分十进制记法（ dotted decimal notation）。如下图。显然，128.11331比1000000000001100010001114写起来要方便得多。<br>
<img src="https://ArsenicX.github.io//post-images/1587902593125.png" alt="" loading="lazy"></p>
<ol start="2">
<li>IP地址分类<br>
以前IP有过ABC类的区分，如下图。<br>
<img src="https://ArsenicX.github.io//post-images/1587898490388.png" alt="" loading="lazy"></li>
</ol>
<ul>
<li>A类、B类和C类地址的网络号字段（在图中这个字段是灰色的）分别为1个、2个和3个字节长，而在网络号字段的最前面有1~3位的类别位，其数值分别规定为0,10和110。</li>
<li>A类、B类和C类地址的主机号字段分别为3个、2个和1个字节长。</li>
<li>D类地址（前4位是110用于多播（一对多通信）。我们将在46节讨论P多播</li>
<li>E类地址（前4位是1111）保留为以后用。</li>
</ul>
<hr>
<ul>
<li>A类地址：
<ul>
<li>网络号字段占1字节，只有7位可供使用（该字节的第一位已固定为0），可指派的网络号是126个（即127-2）。减2的原因是：第一，IP地址中的全0表示“这个 （this）”。网络号字段为全0的IP地址是个保留地址，意思是“本网络”；第二，网络号为127（即01111111）留作为本地软件环回测试 （loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如127.0.0.1）的IP数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。</li>
<li>主机号占3个字节，因此每一个A类网络中的最大主机数是224-2，即16777214。这里减2的原因是：全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址（例如，一主机的IP地址为5.6.7.8，则该主机所在的网络地址就是5.0.0.0），而全1表示“所有的（all）”，因此全1的主机号字段表示该网络上的所有主机。</li>
<li>IP地址空间共有2<sup>32</sup>（即4294967296）个地址。整个A类地址空间共有2<sup>31</sup>个地址，占整个IP地址空间的50%</li>
</ul>
</li>
<li>B类地址
<ul>
<li>网络号字段有2个字节，但前面两位（10）已经固定了，只剩下14位可以进行分配。因为网络号字段后面的14位无论怎样取值也不可能出现使整个2字节的网络号字段成为全0或全1，因此这里不存在网络总数减2的问题。但实际上B类网络地址128.0.0.0是不指派的，而可以指派的B类最小网络地址是128.1.0.0【COME06】。因此B类地址可指派的网络数为2<sup>14</sup>-1，即16383。</li>
<li>B类地址的每一个网络上的最大主机数是2<sup>16</sup>2，即65534。这里需要减2是因为要扣除全0和全1的主机号。整个B类地址空间共约有2<sup>30</sup>个地址，占整个IP地址空间的25%</li>
</ul>
</li>
<li>C类地址:
<ul>
<li>有3个字节的网络号字段，最前面的3位是（110），还有21位可以进行分配。C类网络地址192.0.0.0也是不指派的，可以指派的C类最小网络地址是192.0.1.0【COME06】，因此C类地址可指派的网络总数是2<sup>21</sup>-1，即2097151</li>
<li>每一个C类地址的最大主机数是2<sup>8</sup>-2，即254.整个C类地址空间共约有2<sup>29</sup>个地址，占整个IP地址的12.5%。</li>
</ul>
</li>
</ul>
<p>这样，我们就可得出表所示的IP地址的指派范围。<br>
<img src="https://ArsenicX.github.io//post-images/1587903430445.png" alt="" loading="lazy"><br>
需要指出，ABC这个分类方法已经成为历史，现在广泛使用无分类的IP地址。但是需要大致了解下，以便后续学习<br>
<img src="https://ArsenicX.github.io//post-images/1587903465346.png" alt="" loading="lazy"></p>
<p>IP 地址的一些重要特点 ：</p>
<ol>
<li>IP 地址是一种分等级的地址结构。分两个等级的好处是：
<ul>
<li>IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li>
<li>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li>
</ul>
</li>
<li>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。是：
<ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机(multihomed host)。</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。</li>
</ul>
</li>
<li>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。</li>
<li>所有分配到网络号 net-id 的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。<br>
<img src="https://ArsenicX.github.io//post-images/1587905458363.png" alt="" loading="lazy"><br>
注意：当两个路由器直接相连时（例如通过一条租用线路），在连线两端的接口处，可以分配也可以不分配I地址。如分配了IP地址，则这一段连线就构成了一种只包含段线路的特殊“网络”（如图中的N1，N2和N3）。之所以叫做“网络”是因为它有IP地址。但为了节省IP地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配IP地址。通常把这样的特殊网络叫做无编号网络（ unnumbered network）或无名网络（ anonymous network）【COME06】</li>
</ol>
<h3 id="三-ip地址和硬件">三. IP地址和硬件</h3>
<p>在数据传送时，网络层有源主机IP和目标主机IP，数据传输层有源主机MAC和目标主机MAC，那么二者有什么区别吗？<br>
在网络层中，目标主机IP始终不变。只会傻了吧唧一直说”我要去XXX“<br>
在数据传输层中，目标主机MAC是随时变化的，一直指向当下该数据帧应该去向的路由器的MAC地址。而这个地址是由路由器填写在数据中的，至于为什么路由器知道数据下一步应该发给谁，下一节ARP会介绍<br>
<img src="https://ArsenicX.github.io//post-images/1587906322076.png" alt="" loading="lazy"></p>
<h3 id="四-地址解析协议arp">四. 地址解析协议ARP</h3>
<p>接着上面的问题，路由器怎么根据我的目标IP地址，知道这个目标主机对应的MAC地址呢？<br>
答：ARP<br>
不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。<br>
每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>
<img src="https://ArsenicX.github.io//post-images/1587906561441.png" alt="" loading="lazy"><br>
<img src="https://ArsenicX.github.io//post-images/1587906596027.png" alt="" loading="lazy"></p>
<p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。<br>
也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP，然后按以下步骤找出主机B的硬件地址。<br>
<img src="https://ArsenicX.github.io//post-images/1587906989784.png" alt="" loading="lazy"></p>
<ol>
<li>ARP进程在本局域网上广播发送一个ARP请求分组。</li>
<li>在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。</li>
<li>主机B的IP地址与ARP请求分组中要查询的P地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的硬件地址。由于其余的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理睬这个ARP请求分组。注意：虽然ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址</li>
<li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。<br>
当主机A向B发送数据报时，很可能以后不久主机B还要向A发送数据报，因而主机B也可能要向A发送ARP请求分组。为了减少网络上的通信量，主机A在发送其ARP请求分组时，就把自己的IP地址到硬件地址的映射写入ARP请求分组。当主机B收到A的ARP请求分组时，就把主机A的这一地址映射写入主机B自己的ARP高速缓存中。以后主机B向A发送数据报时就很方便了</li>
</ol>
<p>可见ARP高速缓存非常有用。如果不使用ARP高速缓存，那么任何一台主机只要进行次通信，就必须在网络上用广播方式发送ARP请求分组，这就使网络上的通信量大大增加。ARP把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送ARP请求分组。<br>
ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间（例如，10~20分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机A和B通信。A的ARP高速缓存里保存有B的硬件地址。但B的网络适配器突然坏了，B立即更换了一块，因此B的硬件地址就改变了。假定A还要和B继续通信。A在其ARP高速缓存中査找到B原先的硬件地址，并使用该硬件地址向B发送数据帧。但B原先的硬件地址已经失效了，因此A无法找到主机B。但是过了段不长的生存时间，A的ARP高速缓存中已经删除了B原先的硬件地址，于是A重新广播发送ARP请求分组，又找到了B。<br>
<img src="https://ArsenicX.github.io//post-images/1587907356268.png" alt="" loading="lazy"><br>
请注意，ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如图中，主机H1就无法解析出另一个局域网上主机H2的硬件地址（实际上主机H1也不需要知道远程主机H2的硬件地址）。主机H1发送给H2的IP数据报首先需要通过与主机H1连接在同一个局域网上的路由器R1来转发。因此主机H1这时需要把路由器R1的IP地址IP3解析为硬件地址HA3，以便能够把IP数据报传送到路由器R1。然后，R1从转发表找出了下一跳路由器R2同时使用ARP解析出R2的硬件地址HA5。于是IP数据报按照硬件地址HA5转发到路由器R2。路由器R2在转发这个IP数据报时用类似方法解析出目的主机H2的硬件地址HA2，使IP数据报最终交付主机H2。<br>
（从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道）</p>
<p>因此我们可以归纳出ARP的使用场景:</p>
<ul>
<li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li>
<li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li>
</ul>
<h3 id="五-ip数据报格式">五. IP数据报格式</h3>
<figure data-type="image" tabindex="2"><img src="https://ArsenicX.github.io//post-images/1587907693184.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Regular expression]]></title>
        <id>https://ArsenicX.github.io/regular-expression/</id>
        <link href="https://ArsenicX.github.io/regular-expression/">
        </link>
        <updated>2020-03-25T05:01:25.000Z</updated>
        <content type="html"><![CDATA[<p>https://regex101.com</p>
<style>
table th:first-of-type {
    width: 20%;
}
table th:nth-of-type(2) {
    width: 10%;
}
table th:nth-of-type(3) {
    width: 70%;
}
</style>
<table>
<thead>
<tr>
<th>元字符</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>任意1个字符</td>
<td>.</td>
<td></td>
</tr>
<tr>
<td>字母数字+下划线</td>
<td>\w</td>
<td></td>
</tr>
<tr>
<td>数字</td>
<td>\d</td>
<td></td>
</tr>
<tr>
<td>空白字符</td>
<td>\s</td>
<td>空格、tab、换行</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>锚点</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>边界</td>
<td>\b</td>
<td>用于单词</td>
</tr>
<tr>
<td></td>
<td>^</td>
<td>^Ha表示以Ha开头的句子。注意是句子，而不是词组</td>
</tr>
<tr>
<td></td>
<td></td>
<td>在[]中，^表示非。<code>[^a-z]</code>表示：不是a-z的任意字符</td>
</tr>
<tr>
<td></td>
<td>$</td>
<td>Ha$表示以Ha结尾的句子。注意是句子，而不是词组</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>重复</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>出现0次或者一次</td>
<td>?</td>
<td>?前面的字符可以出现0次或者1次</td>
</tr>
<tr>
<td>出现0次或者多次</td>
<td>*</td>
<td>*前面的字符可以出现0次或者多次</td>
</tr>
<tr>
<td>出现1次或者多次</td>
<td>+</td>
<td>+前面的字符可以出现一次或者多次</td>
</tr>
<tr>
<td>出现a次到b次</td>
<td>{a,b}</td>
<td>{}前面的字符可以出现a次到b次</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>贪婪模式</td>
<td>*</td>
<td>尽可能多地匹配相符内容</td>
</tr>
<tr>
<td>懒惰模式</td>
<td>*?</td>
<td>尽可能少地匹配相符内容</td>
</tr>
<tr>
<td>侵占模式</td>
<td>*+</td>
<td>尽可能多地匹配相符内容, 绝不留给其他部分使用</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>组</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字符集</td>
<td>[]</td>
<td>注意：这是一个字符</td>
</tr>
<tr>
<td></td>
<td></td>
<td>[ab4.7*/f] 表示匹配“ab4.7*/f”中的任意一个</td>
</tr>
<tr>
<td></td>
<td></td>
<td>[A-z3-87] 中的“-”是范围，表示匹配从大A到小z或从3到87中的任何一个 <br>（A=65，z=122，有大小顺序之分）</td>
</tr>
<tr>
<td>分组</td>
<td>()</td>
<td><code>M(a|b|ab)</code>表示匹配Ma、Mb和Mab</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$1、$2...可以用来代替原文中匹配到的组</td>
</tr>
<tr>
<td></td>
<td></td>
<td>在()中加入“?:”，表示不设为分组，例：&quot;(?:a)(b)&quot; 此时$1就是&quot;b&quot;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>前瞻</td>
<td>(?=)</td>
<td>检查特定字符串之后是否包括所需字符</td>
</tr>
<tr>
<td></td>
<td></td>
<td>abc(?=de)：表示先检查整段字符串中是否含有abc，如果含有，就看<strong>abc的位置</strong>后面是不是剩下的东西（即<code>de</code>）;若不是，则匹配失败</td>
</tr>
<tr>
<td>后顾</td>
<td>(?&lt;=)</td>
<td>检查特定字符串之前是否包括所需字符</td>
</tr>
<tr>
<td></td>
<td></td>
<td>(?&lt;=de)abc：表示先检查整段字符串中是否含有abc，如果含有，就看<strong>abc的位置</strong>前面是不是剩下的东西（即<code>de</code>）;若不是，则匹配失败</td>
</tr>
<tr>
<td>瞻前顾后</td>
<td></td>
<td>关于前瞻后顾中的等号=，可以换成叹号!来表示否定。<br>即如果有剩下的内容则不匹配，用于<strong>排除特定字符串</strong>的场景</td>
</tr>
<tr>
<td></td>
<td></td>
<td>比如：<code>adv(?!ice)</code>会过滤 adv、 advert 以及 advertisement，但不会过滤 advice</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>替换</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>自己</td>
<td>\0</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂]]></title>
        <id>https://ArsenicX.github.io/other/</id>
        <link href="https://ArsenicX.github.io/other/">
        </link>
        <updated>2020-03-25T05:00:42.000Z</updated>
        <content type="html"><![CDATA[<p>五大常用算法：https://blog.csdn.net/ling_wang/article/details/81560925<br>
在Mac上完全删除android studio初始配置文件：https://blog.csdn.net/qq_21996633/article/details/51079380</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Data Structure]]></title>
        <id>https://ArsenicX.github.io/data-structure/</id>
        <link href="https://ArsenicX.github.io/data-structure/">
        </link>
        <updated>2020-03-25T04:58:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="小技巧">小技巧</h3>
<ul>
<li>怎么获得1-100的随机数：系统自带的随机数函数会返回一个未知位数的随机数，可以把这个数对100取余</li>
</ul>
<h2 id="总结">总结：</h2>
<p>1.<code>float</code>和<code>double</code><br>
<code>scanf(&quot;%lf&quot;) printf(&quot;%f&quot;)</code> 注意一个是<code>lf</code>，一个是<code>f</code></p>
<ol start="2">
<li>
<p>运算符优先级：单目 &gt; 算术(加减乘除) &gt; 关系(==、&gt;=...) &gt; 赋值<br>
单目运算符，比如<code>a*-b</code>：表示的是先对b取相反数，然后再与a相乘。单目优先级最高<br>
多个关系运算符中，==和!=最低。例如：<code>5&gt;3==6&gt;4</code>表示的是<code>(5&gt;3)==(6&gt;4)</code>，最后返回的是1</p>
</li>
<li>
<p><code>switch-case</code><br>
虽然样子和功能看上去类似<code>if else</code>嵌套<br>
但是用debug断点就可以看到，<code>if else</code>是从第一条if开始，一个一个向下判断是否匹配，费时费力；而<code>switch-case</code>是直接跳到对应的<code>case</code>语句<br>
这样带来的好处就是，<code>switch-case</code>的效率不会被候选匹配项的数量影响</p>
</li>
</ol>
<blockquote>
<p>常见用法：成绩评定级别（90分以上为A，80-89为B...）</p>
<pre><code class="language-java">switch（score/10）{
case 10:
case 9: printf(&quot;A&quot;);
...}
</code></pre>
</blockquote>
<ol start="4">
<li></li>
<li></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开发者指南 - 学习笔记]]></title>
        <id>https://ArsenicX.github.io/android-kai-fa-zhe-zhi-nan-xue-xi-bi-ji/</id>
        <link href="https://ArsenicX.github.io/android-kai-fa-zhe-zhi-nan-xue-xi-bi-ji/">
        </link>
        <updated>2020-03-25T04:55:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="官网地址"><a href="https://developer.android.google.cn/guide">官网地址</a></h1>
<h1 id="第一部分-app-basics">第一部分 App Basics：</h1>
<h1 id="入门">入门</h1>
<ul>
<li>
<p>在Design标签下，点击Button图标，会出现一个Edit Baseline<img src="https://ArsenicX.github.io//post-images/1585280651360.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>Intent</strong>：intent.putExtra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在您的应用与其他应用交互时这些键始终保持唯一</p>
<pre><code class="language-java">public static final String EXTRA_MESSAGE = &quot;com.example.myfirstapp.MESSAGE&quot;;
intent.putExtra(EXTRA_MESSAGE, message);
</code></pre>
</li>
<li>
<p><strong><a href="https://developer.android.google.cn/guide/components/fundamentals">应用可以通过一些途径与其他应用共享数据以及访问系统服务</a></strong></p>
<ol>
<li>可以安排两个应用共享同一 Linux 用户 ID，在这种情况下，它们能够相互访问彼此的文件。 为了节省系统资源，可以安排具有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM（应用还必须使用相同的证书签署）</li>
</ol>
</li>
</ul>
<h1 id="资源文件-resources">资源文件 Resources</h1>
<h2 id="res资源目录及限定符"><code>res/</code>资源目录及限定符</h2>
<h3 id="res目录内支持的资源目录"><code>res/</code>目录内支持的资源目录</h3>
<table>
<thead>
<tr>
<th>目录</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>animator/</td>
<td>用于定义<a href="https://developer.android.google.cn/guide/topics/graphics/prop-animation.html">属性动画</a>的 XML 文件。</td>
</tr>
<tr>
<td>anim/</td>
<td>定义<a href="https://developer.android.google.cn/guide/topics/graphics/view-animation.html#tween-animation">渐变动画</a>的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 <code>animator/</code> 目录。）</td>
</tr>
<tr>
<td>color/</td>
<td>用于定义颜色状态列表的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/color-list-resource.html">颜色状态列表资源</a></td>
</tr>
<tr>
<td>drawable/</td>
<td>位图文件（<code>.png</code>、<code>.9.png</code>、<code>.jpg</code>、<code>.gif</code>）或编译为以下可绘制对象资源子类型的 XML 文件：<br> 1.  位图文件<br> 2.  九宫格（可调整大小的位图）<br> 3.  状态列表<br> 4.  形状<br> 5.  动画可绘制对象<br> 6.  其他可绘制对象<br>  <br>请参阅 <a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource.html">可绘制对象资源</a>。</td>
</tr>
<tr>
<td>mipmap/</td>
<td>适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 <code>mipmap/</code> 文件夹管理启动器图标的详细信息，请参阅<a href="https://developer.android.google.cn/tools/projects/index.html#mipmap">管理项目概览</a>。</td>
</tr>
<tr>
<td>layout/</td>
<td>用于定义用户界面布局的 XML 文件。 请参阅<a href="https://developer.android.google.cn/guide/topics/resources/layout-resource.html">布局资源</a>。</td>
</tr>
<tr>
<td>menu/</td>
<td>用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/menu-resource.html">菜单资源</a>。</td>
</tr>
<tr>
<td>raw/</td>
<td>要以原始形式保存的任意文件。要使用原始 <code>InputStream</code> 打开这些资源，请使用资源 ID（即 <code>R.raw.filename</code>）调用 <code>Resources.openRawResource()</code>。<br>但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 <code>assets/</code> 目录下（而不是 <code>res/raw/</code>）。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 <code>AssetManager</code> 读取这些文件。</td>
</tr>
<tr>
<td>values/</td>
<td>包含字符串、整型数和颜色等简单值的 XML 文件。<br><br/>其他 <code>res/</code> 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均定义一个资源。例如，<code>&lt;string&gt;</code> 元素创建 <code>R.string</code> 资源，<code>&lt;color&gt;</code> 元素创建 <code>R.color</code> 资源。<br><br>由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：<br> 1.  arrays.xml，用于资源数组（<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#TypedArray">类型化数组</a>）。<br> 2.  colors.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Color">颜色值</a>。<br> 3.  dimens.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Dimension">尺寸值</a>。<br> 4.  strings.xml：<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html">字符串值</a>。<br> 5.  styles.xml：<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html">样式</a><br>请参阅<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html">字符串资源</a>、<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html">样式资源</a>和<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html">更多资源类型</a>。</td>
</tr>
<tr>
<td>xml/</td>
<td>可以在运行时通过调用 <code>Resources.getXML()</code> 读取的任意 XML 文件。各种 XML 配置文件（如<a href="https://developer.android.google.cn/guide/topics/search/searchable-config.html">可搜索配置</a>）都必须保存在此处。</td>
</tr>
</tbody>
</table>
<h3 id="资源限定符"><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#table2">资源限定符</a></h3>
<table>
<thead>
<tr>
<th>配置</th>
<th>限定符值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>语言和区域</td>
<td>示例：<br/><code>en</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>fr</code><br>
<code>en-rUS</code><br>
<code>fr-rFR</code><br>
<code>fr-rCA</code><br>
等等    | 语言通过由两个字母组成的 <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO 639-1</a> 语言代码定义，可以选择后跟两个字母组成的 <a href="https://www.iso.org/obp/ui/#iso:pub:PUB500001:en">ISO 3166-1-alpha-2</a> 区域码（前带小写字母“<code>r</code>”）。 |<br>
| smallestWidth | sw<N>dp<br>示例：<br><code>sw320dp</code> <code>sw600dp</code> <code>sw720dp</code> | 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 <code>&lt;N&gt;</code>dp。 |<br>
| 屏幕尺寸      | small<code></code>normal<code></code>large<code></code>xlarge                    | <code>small</code>：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。<br/> <code>normal</code>：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。 <br/><code>large</code>：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。<br/> <code>xlarge</code>：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。<em>API 级别 9 中的新增配置。</em> |<br>
| ...           | ...                                                | ...                                                          |<br>
<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#BestMatch"><strong>系统对于不同资源限定符的选择算法</strong></a><br> 1. 淘汰掉和设备冲突的资源文件。比如设备如果是英文<code>en</code>的，就会先直接排除掉<code>fr</code>、<code>cn</code>等限定符的资源<br> 2. 依照<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#table2">此表</a><strong>从上到下</strong>寻找有没有匹配的。即先找有没有<em>移动国家代码 <code>MCC/MNC</code></em> 限定的资源，有的话直接排除其他；反之寻找有没有<em>语言和区域</em> 限定的资源。<br> 3. 重复第2步，从二级目录开始依次淘汰，只到剩下只有一个资源目录。比如现在已经通过<em>语言和区域</em> 排除过后依旧剩下了3个资源目录，则再看语言限定符之后，有无<em>布局方向</em> 限定符，有的话排除其他；反之寻找有没有<em>屏幕基本尺寸 <code>smallestWidth</code></em>，只到剩下最后一个资源文件夹。<br><br>	<strong>注意⚠️：<em>屏幕像素密度 <code>dpi</code></em> 为特例，不能淘汰</strong> <br>		如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html">支持多种屏幕</a>。<br>		根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统<strong>不会</strong>使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。<br><br>举个栗子🌰：</p>
<blockquote>
<p>假设目前有以下资源目录：</p>
<pre><code>drawable/
drawable-en/
drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</code></pre>
<p>且设备的配置如下：</p>
<p>​	语言区域 = <code>en-GB</code><br>
​	屏幕方向 = <code>port</code><br>
​	屏幕像素密度 = <code>hdpi</code><br>
​	触摸屏类型 = <code>notouch</code><br>
​	主要文本输入法 = <code>12key</code></p>
<p><br>首先，可以排除<code>drawable-fr-rCA/</code> 因为和设备配置冲突</p>
<pre><code class="language-java">drawable/
drawable-en/
// drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</code></pre>
<p>其次，因为目前目录中有语言限定符，且符合设备，所以可以继续排除非<code>en</code>开头的限定符</p>
<pre><code class="language-java">// drawable/
drawable-en/
drawable-en-port/
drawable-en-notouch-12key/
// drawable-port-ldpi/
// drawable-port-notouch-12key/
</code></pre>
<p>筛选过后还剩下不止一个资源，所以重复第二步方法筛选。因为<code>port</code>优先级比<code>notouch</code>高，所以排除<code>notouch</code></p>
<pre><code class="language-java">// drawable-en/
drawable-en-port/
// drawable-en-notouch-12key/
</code></pre>
<p>最后得到唯一的资源目录。之后在程序请求资源时都将会在该目录下找</p>
</blockquote>
<h2 id="运行时变更配置如何处理">运行时变更配置如何处理</h2>
<p>A. 在配置变更期间保留对象：<br>	通常我们可以依靠系统通过<code>onSaveInstanceState()</code> 回调保存的 <code>Bundle</code>， 但是它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。所以当重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作时，此时建议通过保留<code>Fragment</code>来减轻重新初始化 Activity 的负担，可以在 <code>Fragment</code>中包含要保留的有状态对象的<strong>引用</strong>。<br><br>要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：</p>
<p>​	1. 扩展 <code>Fragment</code> 类并声明对有状态对象的引用。</p>
<p>​	2. 在创建片段后调用 <code>setRetainInstance(boolean)</code>。</p>
<p>​	3. 将片段添加到 Activity。</p>
<p>​	4. 重启 Activity 后，使用 <code>FragmentManager</code> 检索片段。<br>例如：</p>
<pre><code class="language-java">public class RetainedFragment extends Fragment {

    // data object we want to retain
    private MyDataObject data;

    // this method is only called once for this fragment
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // retain this fragment
        setRetainInstance(true);
    }

    public void setData(MyDataObject data) {
        this.data = data;
    }

    public MyDataObject getData() {
        return data;
    }
}
</code></pre>
<blockquote>
<p>**注意⚠️：**尽管可以存储任何对象，但是切勿传递与 <code>Activity</code> 绑定的对象，例如，<code>Drawable</code>、<code>Adapter</code>、<code>View</code> 或其他任何与 <code>Context</code> 关联的对象。以免内存泄漏。</p>
</blockquote>
<p>然后，使用 <code>FragmentManager</code> 将片段添加到<code>Activity</code>。在运行时配置变更期间再次启动<code>Activity</code>时，您可以获得片段中的数据对象。 例如，按如下方式定义<code>Activity</code>：</p>
<pre><code class="language-java">public class MyActivity extends Activity {

    private RetainedFragment retainedFragment;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // find the retained fragment on activity restarts
        FragmentManager fm = getFragmentManager();
        retainedFragment = (RetainedFragment) fm.findFragmentByTag(“data”);

        // create the fragment and data the first time
        if (retainedFragment == null) {
            // add the fragment
            retainedFragment = new RetainedFragment();
            fm.beginTransaction().add(retainedFragment, “data”).commit();
            // load the data from the web
            retainedFragment.setData(loadMyData());
        }

        // the data is available in retainedFragment.getData()
        ...
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // store the data in the fragment
        retainedFragment.setData(collectMyLoadedData());
    }

</code></pre>
<p>在此示例中，<code>onCreate()</code> 添加了一个片段或恢复了对它的引用。此外，<code>onCreate()</code> 还将有状态的对象存储在片段实例内部。<code>onDestroy()</code> 对所保留的片段实例内的有状态对象进行更新。</p>
<p><br><br>B. 自行处理配置变更：<br>	如果应用在配置改变时无需更新资源，并且如果因性能限制需要尽量避免重启，则可声明 <code>Activity</code> 将自行处理配置变更，这样可以阻止系统重启 <code>Activity</code>。<br></p>
<blockquote>
<p>​	自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在您<strong>必须</strong>避免 Activity 因配置变更而重启这一<strong>万般无奈</strong>的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并<strong>不建议</strong>使用此方法。</p>
</blockquote>
<p>如果要声明由 <code>Activity</code> 处理配置变更，在清单文件中添加<code>android:configChanges</code>元素即可。在其<a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config">属性文档</a>中列出了可以添加的属性值。</p>
<pre><code class="language-html">&lt;activity android:name=&quot;.MyActivity&quot;
          android:configChanges=&quot;orientation|keyboardHidden&quot;
          android:label=&quot;@string/app_name&quot;&gt;
</code></pre>
<p>现在，当其中一个配置发生变化时，<code>MyActivity</code> 便不会重启。相反，<code>MyActivity</code> 会收到对 <code>onConfigurationChanged()</code> 的调用。向此方法传递 <code>Configuration</code> 对象指定新设备配置。您可以通过读取<code>Configuration</code> 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的<code>Resources</code> 对象会相应地进行更新，以根据新配置返回资源，这样，您就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。</p>
<blockquote>
<p><strong>注意：<strong>从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，</strong>“屏幕尺寸”也会发生变化</strong>。因此，在开发针对 API 级别 13 或更高版本（正如 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min"><code>minSdkVersion</code></a> 和 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target"><code>targetSdkVersion</code></a> 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 <code>&quot;orientation&quot;</code> 值以外，您还必须添加 <code>&quot;screenSize&quot;</code> 值。</p>
</blockquote>
<p>例如，以下 <code>onConfigurationChanged()</code> 实现检查当前设备方向：</p>
<pre><code class="language-java">@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    // Checks the orientation of the screen
    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show();
    } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){
        Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre>
<blockquote>
<p>​	在声明由 Activity 处理配置变更时，您有责任重置要为其提供备用资源的所有元素。 如果您声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 <code>onConfigurationChanged()</code> 期间将每个资源重新分配给每个元素。</p>
<p>​	如果无需基于这些配置变更更新应用，则可不用实现 <code>onConfigurationChanged()</code>。在这种情况下，仍将使用在配置变更之前用到的所有资源。</p>
</blockquote>
<p>如需了解有关可以在 Activity 中处理哪些配置变更的详细信息，请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config"><code>android:configChanges</code></a> 文档和 <a href="https://developer.android.google.cn/reference/android/content/res/Configuration.html"><code>Configuration</code></a>类。</p>
<h2 id="本地化-eng"><a href="https://developer.android.google.cn/guide/topics/resources/localization">本地化 Eng</a></h2>
<h2 id="复合xml-资源-eng"><a href="https://developer.android.google.cn/guide/topics/resources/complex-xml-resources">复合XML 资源 Eng</a></h2>
<h2 id="资源类型详解-eng"><a href="https://developer.android.google.cn/guide/topics/resources/available-resources">资源类型详解 Eng</a></h2>
<h1 id="应用清单-manifest">应用清单 manifest</h1>
<h2 id="应用清单">应用清单</h2>
<p>​	<code>android:label</code>用来指定<code>app</code>名称或<code>activity</code>名称。因为<code>activity</code>比<code>application</code>更具体，所以会优先使用<code>activity</code>中的<code>android:label</code>。</p>
<h2 id="清单文件结构及详解"><a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro#filestruct">清单文件结构及详解</a></h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;manifest&gt;

    &lt;uses-permission /&gt;
    &lt;permission /&gt;
    &lt;permission-tree /&gt;
    &lt;permission-group /&gt;
    &lt;instrumentation /&gt;
    &lt;uses-sdk /&gt;
    &lt;uses-configuration /&gt;  
    &lt;uses-feature /&gt;  
    &lt;supports-screens /&gt;  
    &lt;compatible-screens /&gt;  
    &lt;supports-gl-texture /&gt;  

    &lt;application&gt;

        &lt;activity&gt;
            &lt;intent-filter&gt;
                &lt;action /&gt;
                &lt;category /&gt;
                &lt;data /&gt;
            &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/activity&gt;

        &lt;activity-alias&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/activity-alias&gt;

        &lt;service&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data/&gt;
        &lt;/service&gt;

        &lt;receiver&gt;
            &lt;intent-filter&gt; . . . &lt;/intent-filter&gt;
            &lt;meta-data /&gt;
        &lt;/receiver&gt;

        &lt;provider&gt;
            &lt;grant-uri-permission /&gt;
            &lt;meta-data /&gt;
            &lt;path-permission /&gt;
        &lt;/provider&gt;

        &lt;uses-library /&gt;

    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
<h2 id="文件约定规则">文件约定规则</h2>
<ul>
<li>元素：
<ul>
<li>只有 <code>&lt;manifest&gt;</code> 和 <code>&lt;application&gt;</code> 元素是必需的，它们都必须存在并且只能出现一次。</li>
<li>同一级别的元素通常不分先后顺序。例如，<code>&lt;activity&gt;</code>、<code>&lt;provider&gt;</code> 和 <code>&lt;service&gt;</code> 元素可以按任何顺序混合在一起。但这条规则有两个主要例外：
<ul>
<li><code>&lt;activity-alias&gt;</code> 元素必须跟在别名所指的 <code>&lt;activity&gt;</code> 之后。</li>
<li><code>&lt;application&gt;</code> 元素必须是 <code>&lt;manifest&gt;</code> 元素内最后一个元素。换言之，<code>&lt;/manifest&gt;</code> 结束标记必须紧接在 <code>&lt;/application&gt;</code> 结束标记后。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="权限-permission"><a href="https://developer.android.google.cn/guide/topics/permissions/overview">权限 Permission</a></h1>
<h2 id="概述-eng">概述 Eng</h2>
<ul>
<li>
<p>对于硬件设备的需求的权限声明</p>
<p>​	在调用设备硬件（比如蓝牙或相机）时，需要用户的授权才能使用。但是，并不是所有的设备都有这些硬件，所以别忘了在用户清单中添加<code>&lt;uses-feature&gt;</code>（<code>&lt;uses-feature&gt;</code>说明可见「设备 Device - 应用兼容性概述 Device compatibility overview - 设备特征（Feature ID）」）<br>	如果你声明了<code>android:required=&quot;false&quot;</code>，则 Google Play 会允许没有该硬件的设备安装。而你要在运行时使用 <code>PackageManager.hasSystemFeature()</code>检测设备是否具有某项硬件，如果没有，记得停用使用该硬件的功能。</p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#permission_enforcement">权限的其他功用 Eng</a></p>
<p>​	权限并不只是为了去调用设备的功能，我们也可以自定义权限来自定义限制。</p>
<ol>
<li>Activity 权限限制</li>
</ol>
<p>​	 在<code>&lt;activity&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以跳转该 Activity。<br>	这个权限会在``Context.startActivity()<code>和</code>Activity.startActivityForResult()<code>期间检查，若没有权限的话则调用者会抛出</code>SecurityException`异常。</p>
<ol start="2">
<li>Service 权限限制</li>
</ol>
<p>​	在<code>&lt;service&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以启用或绑定该 Service。<br>	这个权限会在<code>Context.startService()</code>，<code>Context.stopService()</code>和<code>Context.bindService()</code>过程中检查，若没有权限的话则调用者会抛出<code>SecurityException</code>异常。</p>
<ol start="3">
<li>Broadcast 权限限制</li>
</ol>
<p>​	在<code>&lt;receiver&gt;</code>标签中使用<code>android:permission</code> 属性的话，则限制了谁才可以向已连接的 BroadcastReceiver发送广播。<br>	因为系统会尝试将广播传递给给定的接受者，所以这个权限会在<code>Context.sendBroadcast()</code>返回后检查；同理，若没有权限的话也不会抛出异常，他只是没有传递出去那个 Intent。</p>
<p>​	同样，也可以给<code>Context.registerReceiver()</code>提供权限去控制 <a href="https://developer.android.google.cn/guide/topics/permissions/overview#broadcast_permission_enforcement">who can broadcast to a programmatically registered receiver. </a>。这种情况下，权限会在调用<code>Context.sendBroadcast()</code>时检查，以去限制哪种广播接收器被允许去接受广播。</p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#auto-adjustments">自动修正权限 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#normal-dangerous">保护等级 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#normal-dangerous">权限组 Eng</a></p>
</li>
<li>
<p><a href="https://developer.android.google.cn/guide/topics/permissions/overview#viewing">查看应用涉及到的权限 Eng</a></p>
</li>
</ul>
<h2 id="使用权限的最佳做法">使用权限的最佳做法</h2>
<h3 id="避免请求不必要的权限">避免请求不必要的权限</h3>
<p>本部分提供了常见的替代方法：</p>
<ol>
<li>改用 Intent<br>	要让应用执行某项任务，有两种方法可以选择。应用可以要求提供权限来自行执行该任务，也可以使用 intent 让其他应用执行该任务。<br>	例如，当我们需要使用摄像头拍照时，可以请求<code>CAMERA</code>权限以便应用直接访问摄像头，也可以使用 Intent 来调用其他支持拍照的应用，这样的话就无需请求<code>CAMERA</code>权限了。比如可以使用 Intent 操作类型 <code>MediaStore.ACTION_IMAGE_CAPTURE</code> 或 <code>MediaStore.ACTION_VIDEO_CAPTURE</code> 来拍摄图像或视频。</li>
</ol>
<pre><code>​	&lt;br&gt;如果使用权限：

- 当您执行操作时，您的应用可以完全控制用户体验。不过，这样需要自行创建对应的界面，会增加代码的复杂性。
- 系统会在运行时或安装时（具体取决于用户的 Android 版本）提示用户授予权限一次。如果用户未授予权限（或之后撤消权限），则应用将根本无法执行操作。

如果使用 intent：

- 您不必为操作设计界面。利用 Intent 而调用的应用将提供界面。
- 用户可以使用他们首选的应用执行任务。例如，用户可以选择用他们喜爱的照片应用拍照。
- 如果用户没有适用于操作的默认应用，则系统会提示用户选择一款应用。如果用户未指定默认处理程序，则他们每次执行此操作时都可能必须处理一个额外的对话框。
</code></pre>
<ol start="2">
<li>
<p>不要让用户感到无所适从</p>
<p>​	如果用户运行的是 Android 6.0（API 级别 23）或更高版本，则用户必须在运行应用时为其授予权限。如果您让用户一次面对大量的权限请求，可能会让用户感到无所适从。<br>	合理的做法是，在用户第一次打开应用时就立即请求所有<strong>必要</strong>的权限。比如您的应用是摄影应用，那在用户首次打开应用的时候被要求授权摄像头权限的时候，用户就不会感到不妥；但是，如果同一应用还具有与联系人分享照片的功能，那就建议不要在首次启动时请求授权<code>READ_CONTACT</code>权限，而是应该在用户进行「分享」操作时再请求。<br>	当然，如果应用提供教程，也可以在教程过后请求提供权限。</p>
</li>
<li>
<p>失去音频焦点后暂停媒体</p>
<p>​	有这样一种使用场景，当用户接电话时，应用需要转入后台并且将其媒体播放器暂停或静音。通常的做法是使用 <code>PhoneStateListener</code> 或监听 <code>android.intent.action.PHONE_STATE</code> 的广播，以监听通话状态有无变化。<br>	可是这种解决方法需要请求 <code>READ_PHONE_STATE</code> 权限，而这个权限将会同时得到用户广泛的敏感数据（比如用户的设备和 SIM 硬件 ID 以及来电的电话号码）</p>
<p>​	这时就可以用另一种方式来解决。您可以通过为应用请求 <code>AudioFocus</code>，在没有 <code>READ_PHONE_STATE</code> 或 <code>MODIFY_PHONE_STATE</code> 权限的情况下检测用户是否在通话中。只需将对音频放入后台所需的代码放入<code>onAudioFocusChange()</code> 事件处理程序，当操作系统转换其音频焦点时，它将自动运行。要详细了解如何执行此操作，请参阅<a href="https://developer.android.google.cn/training/managing-audio/audio-focus.html">此文档</a></p>
</li>
<li>
<p>确定正在运行实例的设备</p>
<p>​	在这种情况下，您需要一个唯一标识符来确定您的应用实例正在哪个设备上运行。<br>	应用可能具有设备特定的偏好设置或消息（例如，在云端为用户保存设备特定的播放列表，以便他们在车上和家里可以有不同的播放列表）。常见的解决方案是利用设备标识符（如 <code>Device IMEI</code>），但这需要 <code>Device ID and call information</code> 权限组（M+ 中为 <code>PHONE</code>）。它还使用一个无法重置且在所有应用之间共享的标识符。<br>	下面两种方法可以替代这些类型的标识符：</p>
<ol>
<li>使用 <code>com.google.android.gms.iid</code> InstanceID API。<code>getInstance(Context context).getID()</code> 将为您的应用实例返回一个唯一设备标识符。结果是一个应用实例作用域标识符，在存储有关应用的信息时，该标识符可用作键，如果用户重新安装应用，该标识符会重置。</li>
<li>使用 <a href="https://developer.android.google.cn/reference/java/util/UUID.html#randomUUID()"><code>randomUUID()</code></a> 之类的基本系统函数创建您自己的标识符，其作用域限定为应用的存</li>
</ol>
</li>
<li>
<p>为广告或用户分析创建唯一标识符</p>
<p>​	在这种情况下，您需要一个唯一标识符来为没有登录您应用的用户构建配置文件（例如，用于广告定位或衡量转化率）。<br>	为广告和用户分析构建配置文件有时需要一个在其他应用之间共享的标识符。此问题的常见解决方案需要利用设备标识符（如 <code>Device IMEI</code>），这需要 <code>Device ID</code> <code>and call information</code> 权限组（API 级别 23+ 中为 <code>PHONE</code>），并且无法由用户重置。无论是上述哪种情况，除了使用不可重置的标识符并请求用户可能认为不寻常的权限外，还会违反 <a href="https://play.google.com/about/developer-content-policy.html">Play 开发者计划政策</a>。<br>	遗憾的是，在这些情况下，使用 <code>com.google.android.gms.iid</code> InstanceID API 或系统函数创建应用作用域 ID 并不是适当的解决方案，因为可能需要在应用之间共享该 ID。一种替代解决方案是使用通过 <code>getId()</code> 方法从<code>AdvertisingIdClient.Info</code> 类中获取的 <code>Advertising Identifier</code>。您可以使用 <code>getAdvertisingIdInfo(Context)</code> 方法创建一个 <code>AdvertisingIdClient.Info</code> 对象，并调用 <code>getId()</code> 方法来使用该标识符。<em><strong>请注意，此方法会产生阻塞</strong></em>，因此，您不应从主线程调用它；有关此方法的详细说明，请点击<a href="https://developer.android.google.cn/google/play-services/id.html">此处</a>。</p>
</li>
</ol>
<h2 id="自定义权限-eng"><a href="https://developer.android.google.cn/guide/topics/permissions/defining">自定义权限 Eng</a></h2>
<h1 id="第二部分-设备-device">第二部分 设备 Device</h1>
<h1 id="应用兼容性-device-compatibility">应用兼容性 Device compatibility</h1>
<h2 id="概述">概述</h2>
<h3 id="设备特征feature-id">设备特征（Feature ID）</h3>
<p>​	为了使你的应用在用户设备上可以正常使用，<code>Android</code>为硬件和软件设置了<code>特征ID</code>。硬件比如加速器传感器，它的特征ID是<code>FEATURE_SENSOR_COMPASS</code>；软件比如小部件widget，他的特征ID是 <code>FEATURE_APP_WIDGETS</code></p>
<p>​	假如你的应用是基于某项特征运作的，并且你不希望没有该特征的设备安装你的应用，你就可以在清单文件中使用<code>&lt;user-feature&gt;</code>来作出限制。</p>
<blockquote>
<p>例如，假设你的应用在没有加速度传感器的设备上会无法使用。这时你就可以在清单文件中加入</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.sensor.compass&quot;
                  android:required=&quot;true&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>
<p>这样，用户在持有没有加速度传感器的设备在Google Play Store下载该应用时就会被拒绝安装。</p>
<p>如果你的应用并不是一定需要该特征的话，你也可以把<code>android:required=&quot;true&quot;</code>的<code>true</code>改为<code>false</code>，然后在运行时判断设备是否具有该特征。如果没有的话再选择停用使用了该特征的功能。</p>
<pre><code class="language-java">PackageManager pm = getPackageManager();
//判断是否具有某特征ID
if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) {
    // This device does not have a compass, turn off the compass feature
    disableCompassFeature();
} 
</code></pre>
</blockquote>
<blockquote>
<p><strong>注意</strong>⚠️：某些系统的权限（<code>permission</code>）会隐式的检查设备是否具有特征（<code>feature ID</code>）。</p>
<p>比如，如果你的应用请求了蓝牙的使用权限：</p>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;
</code></pre>
<p>那Google Play Store就会自动隐式检测设备是否具有蓝牙硬件，若没有的话就会拒绝安装。</p>
<p>如果不想被隐式检查的话就需要手动设置</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.bluetooth&quot;
                  android:required=&quot;false&quot; /&gt;
    ...
&lt;/manifest&gt; 
</code></pre>
</blockquote>
<h3 id="平台版本-platform-version">平台版本 Platform version</h3>
<p>​	因为<code>Android</code>系统的向后兼容特性，我们需要在<a href="https://developer.android.google.cn/studio/build/index.html#build-files"><code>build.gradle</code></a>中设置<code>SdkVersion</code>以保证我们的应用可以正常工作。<br></p>
<pre><code class="language-java">android {
  defaultConfig {
    applicationId 'com.example.myapp'

    // 安装该应用的所需的最低版本API
    minSdkVersion 15

    // 在所有测试设备中，最高API设备的API
    targetSdkVersion 28

    ...
  }
}
</code></pre>
<p>​	<strong>注意⚠️</strong>：<br>	1. 如果<code>manifest</code>和<code>build.gradle</code>中同时设置了<code>minSdkVersion</code> and <code>targetSdkVersion</code>，则以<code>build.gradle</code>为准<br>	2.  <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target"><code>targetSdkVersion</code></a>并不会阻止高于它的设备安装该应用，但是需要注意的是，它决定了该应用是否继承新版本的更改。<br>	例如：</p>
<blockquote>
<p>在<code>Android4.4</code>更新中，为了省电，使用<code>AlarmManager API</code>创建的警报由之前的「准时提醒」改为了「批量同时提醒」</p>
<blockquote>
<p>二者区别：倘若创建了16:01:00和16:01:30两个时间的警报，旧版本会提醒两次，而新版本会合并为一次同时提醒2个事件。比之前减少一次唤醒，节省电量。</p>
</blockquote>
<p>倘若应用<code>targetSdkVersion</code>设置为最新版本，则在运行时警报提醒会变为「批量同时提醒」；而若是没有及时更新<code>targetSdkVersion</code>，则应用在运行时还是会「准时提醒」</p>
</blockquote>
<h2 id="不同屏幕尺寸兼容">不同屏幕尺寸兼容</h2>
<h3 id="使用最小宽度限定符">使用最小宽度限定符</h3>
<p><code>res/layout/main.xml</code>即代表默认布局，<code>res/layout-sw600dp/main.xml</code>即代表屏幕宽度大于等于 600dp 的设备所使用的布局。</p>
<h3 id="使用布局别名">使用布局别名</h3>
<p>​	因为最小宽度限定符只能使用在 Android3.2 以上的设备上面，所以当设备版本号低于 Android3.2 时，仍然会出现布局出错的问题，这是我们就需要专门为 Android3.2 以下的设备新建一个<code>res/layout-large</code>文件夹用来放置适配UI。<br>	可是为了适配 Android3.2 以下的设备专门新开一个文件夹，其中所有的资源都要从<code>res/layout-sw600dp/main.xml</code>复制一份，一方面浪费空间，另一番面后续维护容易遗漏。这时我们就可以使用布局别名。<br>	首先新建一个<code>res/layout/main_twopanes.xml</code>用来放置大尺寸屏幕下的布局和资源，然后修改<code>res/values-large/layout.xml</code>和``res/layout-sw600dp/main.xml`为下：</p>
<pre><code class="language-xml">&lt;resources&gt;
    &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;
&lt;/resources&gt;
</code></pre>
<h3 id="9-格式位图">. 9 格式位图</h3>
<p>​	支持不同尺寸的屏幕，意味着图像资源也需要能够适应不同的尺寸。而在图片的缩放上，经常会出现差强人意的效果，这时我们就可以使用 . 9格式的位图，来固定哪部分可以被缩放拉伸，而哪部分不可以。<br>	例如可用于对话消息框背景，能够在消息文本多少不确定的情况下保持眼睛不变形：<img src="https://upload-images.jianshu.io/upload_images/291600-66b458ac8f0909f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/901" alt="" loading="lazy"><br>	将图像格式改为 <code>.9.png</code>即可使图片成为 .9 格式并支持自定义拉伸位置。左边和上边区域定义可以拉伸的位置，而右边和下边定义图片中内容填充的位置。</p>
<h2 id="适配刘海屏-eng"><a href="https://developer.android.google.cn/guide/topics/display-cutout">适配刘海屏 Eng</a></h2>
<h2 id="声明受限屏幕的支持">声明受限屏幕的支持</h2>
<p>因为一些原因可能我们不想使一个apk同时支持所有屏幕比例的设备，这时我们可以作出一些限制。</p>
<ol>
<li>
<p><a href="https://developer.android.google.cn/training/multiple-apks/screensize.html">针对不同屏幕单独发布apk（依赖Google Play）</a></p>
</li>
<li>
<p>声明最大长宽比<br></p>
<p>​	可以设定一个最大长宽比，当应用在屏幕长宽比超过限定的设备上运行时，应用会做出适配。如果应用定位到 API 26 或更高版本会根据其布局填充屏幕；而 API 25 或更低版本会将应用界面大小限制为长宽比为 16:9 的窗口，手机屏幕将带有黑边运行应用。</p>
<p>​	要为 Android 8.0（API 级别 26）和更高版本设置最大长宽比，请在您的 <code>&lt;activity&gt;</code> 标记中使用 <code>android:MaxAspectRatio</code> 声明最大比例。</p>
<pre><code class="language-xml">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --&gt;
&lt;!-- Use a letterbox on screens larger than 2.4 --&gt;
&lt;activity android:maxAspectRatio=&quot;2.4&quot;&gt;
 ...
&lt;/activity&gt;
</code></pre>
<p>对于 Android 7.1 及更低版本，请在 <code>&lt;application&gt;</code>元素中添加一个 名为 <code>android.max_aspect</code> 的 <code>&lt;meta-data&gt;</code> 元素。</p>
<pre><code class="language-xml">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --&gt;
&lt;!-- Use a letterbox on screens larger than 2.4 --&gt;
&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.4&quot; /&gt;
</code></pre>
<p>如果设置了最大长宽比，请勿忘记同时设置 <code>android:resizeableActivity false</code>。</p>
<blockquote>
<p>有些设备支持分屏模式（同屏多应用）下使用，并且许多应用还支持可调整大小。如果不希望自己的应用支持该模式的话，可以为整个应用或特定 Activity 明确设置 <code>android:resizeableActivity flase</code>属性。</p>
<blockquote>
<p>分屏模式只适用于在 Android 7.0（API 级别 24）或更高版本中运行的所有应用，并且应用默认可调整大小。</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>注⚠️：<strong>如果您的应用不可调整大小，您应该在尽可能多的设备上测试它的行为。 检查所有控件是否均可见。 因为有些设备可让用户</strong>强制</strong>应用进入全屏显示，这会调整这些应用的大小。</p>
</blockquote>
</li>
<li>
<p>声明最大屏幕尺寸<br></p>
<p>​	即使并未完全优化您的应用以<a href="https://developer.android.google.cn/training/multiscreen/screensizes.html">支持不同的屏幕尺寸</a>，Android 仍然可以拉伸大部分应用以适应较大的屏幕。 因此，<strong>几乎从来都没有必要</strong>声明最大屏幕尺寸。</p>
<p>​	不过如果对于 Android 调整应用以适应大屏幕的方式不满意，则可通过在 <code>&lt;supports-screens&gt;</code> 清单标记中指定 <a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#largestWidth"><code>largestWidthLimitDp</code></a> 属性来禁止将大小调整到超出特定宽度。 然后，Android 会启用<a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#compat-mode">屏幕兼容模式</a>（此模式会按照应用支持的最大尺寸屏幕上的绘制方式来绘制布局，然后<strong>放大所有像素以填充屏幕</strong>），<strong>而不是调整布局的大小</strong>。</p>
</li>
<li>
<p>限制应用仅支持平板电脑或电视<br></p>
<p>​	可以使用<code>&lt;supports-screens&gt;</code> <code>manifest</code>元素来阻止手机设备下载您的应用。<br>	例如，以下代码声明只有大屏幕和特大屏幕才能安装您的应用：</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;supports-screens android:smallScreens=&quot;false&quot;
                      android:normalScreens=&quot;false&quot;
                      android:largeScreens=&quot;true&quot;
                      android:xlargeScreens=&quot;true&quot;/&gt;
    ...
&lt;/manifest&gt;
</code></pre>
</li>
<li>
<p>限制应用仅支持特定尺寸和密度<br></p>
<p>​	可以使用<code>&lt;compatible-screens&gt;</code>manifest 元素来定义应用支持的确切屏幕尺寸和密度。 但是，<strong>强烈建议不要</strong>使用此功能，因为未指定的任何尺寸和密度组合都会被视为与应用不兼容的屏幕配置。<br>	<code>&lt;compatible-screens&gt;</code>元素必须包含一个或多个 <code>&lt;screen&gt;</code> 元素。 每个 <code>&lt;screen&gt;</code> 元素都使用 <code>android:screenSize</code> 和 <code>android:screenDensity</code> 属性指定与您的应用兼容的屏幕配置 。 每个 <code>&lt;screen&gt;</code> 元素都<strong>必须同时包含这两个属性</strong>才能指定一个屏幕配置 — 缺少任一属性都会导致该元素无效。<br>	例如，如果您的应用仅与小屏幕尺寸和标准屏幕尺寸（以及一部分屏幕密度）兼容，则 manifest 项将如下所示：</p>
<pre><code class="language-xml">&lt;manifest ... &gt;
    &lt;compatible-screens&gt;
        &lt;!-- all small size screens --&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;ldpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;mdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;hdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;small&quot; android:screenDensity=&quot;xhdpi&quot; /&gt;
        &lt;!-- all normal size screens --&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;ldpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;mdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;hdpi&quot; /&gt;
        &lt;screen android:screenSize=&quot;normal&quot; android:screenDensity=&quot;xhdpi&quot; /&gt;
    &lt;/compatible-screens&gt;
    ...
    &lt;application ... &gt;
        ...
    &lt;application&gt;
&lt;/manifest&gt;
</code></pre>
<p>未在此处明确声明的任意尺寸和密度组合都将受到限制，无法安装该应用。</p>
</li>
</ol>
<h2 id="多种-apk-支持选修"><a href="https://developer.android.google.cn/google/play/publishing/multiple-apks">多种 APK 支持（选修）</a></h2>
<p>​	依赖 Google Play 平台，故选修。</p>
<h2 id="支持不同平台版本">支持不同平台版本</h2>
<h3 id="运行时检查系统版本">运行时检查系统版本</h3>
<p>​	Android 在 Build constant 类中为每个平台版本都提供了独特的代码，在应用中使用这些代码来构建条件，以确保可用这些 API 时才会去执行这些代码。<br>	例如：</p>
<pre><code class="language-java">private void setUpActionBar() {
    // Make sure we're running on Honeycomb or higher to use ActionBar APIs
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
    }
}
</code></pre>
<blockquote>
<p>注：解析 xml 资源时，Android会自动忽略当前设备不支持的 xml 属性。也就是说，对于 xml 资源而言，不需要担心新的属性在旧版本设备上崩溃或报错，因为旧设备会自动忽略掉不认识的属性，不需要像代码一样提前判断版本再操作。</p>
<p>例如： 如果您设置targetSdkVersion =“11”，则默认情况下，您的应用会在Android 3.0及更高版本中包含ActionBar。如果要在 ActionBar 中添加菜单项，您需要在菜单资源 XML 中设置<code>android：showAsAction =“ifRoom”</code>。 而在跨版本的 XML 文件中执行此操作是安全的，因为旧版本的 Android 因为不认识 showAsAction 属性而会忽略掉它（也就是说，您不需要专门区分出一个<code>res/menu-v11/</code>）。</p>
</blockquote>
<h3 id="使用不同主题样式">使用不同主题样式</h3>
<p>​	Android 提供了许多主题样式，可以在 manifest 清单文件中自定义。当你使用了这些主题后，你的应用会自动适配为 Android 最新版的外观和感觉样式。</p>
<p>想让你的 Activity 看起来像个对话框：</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@android:style/Theme.Dialog&quot;&gt;
</code></pre>
<p>想让你的 Activity 有个透明的背景：</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@android:style/Theme.Translucent&quot;&gt;
</code></pre>
<p>想让你的活动使用你自己的主题（自定义主题需要放在 <code>/res/values/styles.xml</code>下）</p>
<pre><code class="language-xml">&lt;activity android:theme=&quot;@style/CustomTheme&quot;&gt;
</code></pre>
<p>想让你的整个应用所有 Activity 都使用某种主题，在<code>&lt;application&gt;</code>中添加<code>android:theme</code> 属性即可</p>
<pre><code class="language-xml">&lt;application android:theme=&quot;@style/CustomTheme&quot;&gt;
</code></pre>
<p>更多的自定义主题设计可以看<a href="https://developer.android.google.cn/guide/topics/ui/themes.html">风格主题向导</a></p>
<h2 id="google-play-上的过滤器选修">Google Play 上的过滤器（选修）</h2>
<p>使用场景：当用户在 Google Play 上搜索或浏览应用以下载时，会根据哪些应用与其设备兼容来过滤搜索结果。</p>
<h1 id="android-wear"><a href="https://developer.android.google.cn/training/wearables">Android Wear</a></h1>
<h1 id="android-tv"><a href="https://developer.android.google.cn/training/tv">Android TV</a></h1>
<h1 id="android-auto"><a href="https://developer.android.google.cn/training/auto">Android Auto</a></h1>
<h1 id="android-things"><a href="https://developer.android.google.cn/things/get-started">Android Things</a></h1>
<h1 id="chrome-os-devices"><a href="https://developer.android.google.cn/chrome-os/intro">Chrome OS Devices</a></h1>
<h1 id="核心内容-eng-日后填坑"><a href="https://developer.android.google.cn/guide/components/activities/intro-activities">核心内容 Eng 日后填坑</a></h1>
<h1 id="完美测试-eng-日后填坑"><a href="https://developer.android.google.cn/training/testing">完美测试 Eng 日后填坑</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github Page + jekyll搭建]]></title>
        <id>https://ArsenicX.github.io/github-page-jekyll-da-jian/</id>
        <link href="https://ArsenicX.github.io/github-page-jekyll-da-jian/">
        </link>
        <updated>2020-03-25T04:54:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-创建repository并pull到本地">一. 创建repository并pull到本地</h2>
<ol>
<li>这里需要注意Repository name一定要是自己的<code>Github账户名.github.io</code><img src="https://ArsenicX.github.io//post-images/1585280966178.jpg" alt="" loading="lazy"></li>
<li>创建好了之后在设置页面添加一个默认的界面样式<br>这步是为了在你以后添加博文的时候会有个初始界面，否则你的新博文是不会显示的<br><img src="https://ArsenicX.github.io//post-images/1585280987063.jpg" alt="" loading="lazy"></li>
<li>将这个新建的项目pull到本地，并将该文件夹下除了<code>.git</code>之外其他文件全部删除（pull项目的具体操作可以看<a href="https://arsenicx.github.io/2018/08/17/git-commands/">Git 常用命令</a>）</li>
</ol>
<h2 id="二-创建自己的主页">二. 创建自己的主页</h2>
<blockquote>
<p>目前两大主流静态博客框架是jekyll和hexo，这里我选用了jekyll</p>
</blockquote>
<ol>
<li>在<a href="http://jekyllthemes.org/">Jekyll Themes</a>中下载一个自己中意的主题（比如<a href="http://jekyllthemes.org/themes/wiki-blog/">Wiki Blog</a>，以下的配置也是基于Wiki Blog的），将下载后的压缩包解压，并将其中所有东西移动到repository目录中。<br>此时在浏览器打开<code>https://arsenicx.github.io/</code>就能看到自己的主页了（记得把链接里面的名称换成自己的）</li>
<li>这时你的个人博客就搭建好了，repository目录下面的_posts文件夹就是你的博文放置的位置。<br>这时就可以用markdown格式来写你的第一篇博文了。</li>
</ol>
<h2 id="三-写自己的第一篇博文">三. 写自己的第一篇博文</h2>
<blockquote>
<p>有些主题可能强制要求在文章头必须写layout、title、date、categories等</p>
</blockquote>
<ol>
<li>正文的格式是markdown格式文本。</li>
<li>在本地修改完repository之后，用git命令提交到Github就可以了，然后过几分钟刷新自己博客的页面就可以看到改动了。</li>
<li>以下是我遇到的一些小问题，一并贴在这里</li>
</ol>
<ul>
<li>有些主题需要在开头之后至少空两行以上才能写正文</li>
<li>如果添加了博文之后，怎么刷新都不出现，则有可能是你的博文日期设置问题。<br>因为jekyll是根据UTC时间设置的，而北京时间是UTC+8的时区，时间过早所以会出现博文不显示的bug，此时只要在博文开头的data后添加一个<code>UTC+8</code>即可，如<code>date:2019-04-08 10:42:03UTC+8</code></li>
<li>当我把我的分类名<code>git_Github</code>改成<code>git&amp;Github</code>时，会发现在首页点击该分类无效了。个人怀疑是<code>&amp;</code>这个字符不能被支持，同样不支持的还有空格等字符。</li>
<li>网站的自定义icon：将自己想要的图片缩放至32*32像素，然后重命名为<code>favicon.ico</code>并放到repository根目录下就好了。可能会需要很久才能实现预览，不必着急。</li>
</ul>
<h2 id="四-win环境搭建本地的jekyll环境选修">四. win环境搭建本地的jekyll环境（选修）</h2>
<blockquote>
<p>目的：<br>每次更改完_post之后都要先提交到Github，然后等一会才能看到实际效果。对于新手来说，更开始不熟悉Markdown效果肯定会更多的使用git push，费时间和精力。<br>而搭建本地的jekyll环境就可以在本地修改完项目后实时预览到变化，待最终确定完博文之后再提交到Github即可。</p>
</blockquote>
<ol>
<li>首先安装Ruby，进入官网<a href="https://ArsenicX.github.io//post-images/1585281016950.jpg">下载页面</a></li>
<li>安装过程中，<strong>建议不要改变任何路径，使用默认就好</strong>，并且建议<strong>选中【加入到环境变量中】</strong><br>（因为我已经安装完成了，下图只做说明选项，不用在意版本号和其他）<br><img src="https://ArsenicX.github.io//post-images/1585281023352.webp" alt="" loading="lazy"></li>
<li>安装完成之后会弹出一个命令行，是让你选择1，2，3来选择安装的，如果你不清楚区别的话按一下<code>Enter</code>回车就好，他会自动检测然后安装<br>（因为我已经安装完成了所以这里就不上图了）</li>
<li>待安装后在命令提示符中分别运行<code>ruby -v</code>和<code>gem -v</code>，结果如果会出现当前安装版本号，则说明此时可以安装jekyll了。<br><img src="https://ArsenicX.github.io//post-images/1585281075413.jpg" alt="" loading="lazy"></li>
<li>待安装后运行<code>jekyll --version</code>，出现版本号则说明安装成功。<br>然后将命令行路径移动到repository的目录下并运行<code>jekyll serve</code>，结果如下图的话，恭喜你，你已经搭建完成了本地的jekyll环境，其中红框所圈地址即为你的博客的本地路径，改动过repository后浏览器输入该地址并刷新即可实时预览<br><img src="https://ArsenicX.github.io//post-images/1585281081832.jpg" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git连接Github]]></title>
        <id>https://ArsenicX.github.io/git-lian-jie-github/</id>
        <link href="https://ArsenicX.github.io/git-lian-jie-github/">
        </link>
        <updated>2020-03-25T04:53:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-配置ssh">一. 配置SSH</h2>
<ol>
<li>
<p>打开git，运行<code>ssh</code>。<br>如果打印以下消息，则说明ssh配置成功。<br><img src="https://ArsenicX.github.io//post-images/1585280803537.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p>运行<code>ssh-keygen -t rsa</code>，用来生成和GitHub关联的key。<br>如果打印以下消息，则说明ssh key生成成功。其中红框部分是ssh key生成的位置。<br><img src="https://ArsenicX.github.io//post-images/1585280815041.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p>进入上图红框处ssh key的位置，并打开id_rsa.pub，复制其中的key文本。<br><img src="https://ArsenicX.github.io//post-images/1585280826062.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>给自己的Github账户添加上一步复制的ssh key，如图操作或者直接<a href="https://github.com/settings/ssh/new">点击我</a>打开页面<br>
<br><img src="https://ArsenicX.github.io//post-images/1585280834731.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>git运行<code>ssh -T git@github.com</code>，第一次时会弹出警告，此时输入<code>YES</code>即可<br>
<br>结果如下图则说明连接成功。<br><img src="https://ArsenicX.github.io//post-images/1585280842513.jpg" alt="" loading="lazy"></p>
</li>
</ol>
<h2 id="二-连接github-repository">二. 连接Github repository</h2>
<ol>
<li>在github上添加新repository（如果已有可以跳过此步骤）<br>（具体步骤省略）</li>
<li>将git命令行的当前路径移动到自己想要保存repository的目录<br>
<br></li>
<li>运行<code>git clone https://github.com/ArsenicX/ArsenicX.github.io.git</code>，<br>
该地址位置如下图：<br>
<img src="https://ArsenicX.github.io//post-images/1585280854780.jpg" alt="" loading="lazy"></li>
</ol>
<br>
参考：https://www.jianshu.com/p/5ad1ae0f7efd
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String]]></title>
        <id>https://ArsenicX.github.io/string/</id>
        <link href="https://ArsenicX.github.io/string/">
        </link>
        <updated>2020-03-25T04:52:29.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>与Char转换</p>
</li>
<li>
<p>charAt()：类似于数组，取出特定位置字符 <code>char c = s.charAt(1);</code></p>
</li>
<li>
<p>toCharArray()：将字符串转换为一个字符数组 <code>char[] arr = s.toCharArray();</code></p>
</li>
<li>
<p>字符串逆置</p>
</li>
<li>
<pre><code></code></pre>
</li>
</ul>
<p>for(int i = 0;i&lt;s.length();i++){<br>
System.out.print(s.charAt(s.length()-i-1));<br>
}</p>
<pre><code>- ```
StringBuilder stringBuilder = new StringBuilder(str);
StringBuilder str2 = stringBuilder.reverse();
return str2.toString();
</code></pre>
<ul>
<li>字符串排序</li>
<li>
<pre><code></code></pre>
</li>
</ul>
<p>char array[]=s.toCharArray();<br>
Arrays.sort(array);<br>
for(char a:array){<br>
System.out.println(a);<br>
}</p>
<pre><code></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合]]></title>
        <id>https://ArsenicX.github.io/ji-he/</id>
        <link href="https://ArsenicX.github.io/ji-he/">
        </link>
        <updated>2020-03-25T04:52:04.000Z</updated>
        <content type="html"><![CDATA[<p>Java的集合类主要由Collection和Map接口派生。</p>
<h1 id="collection接口">Collection接口</h1>
<p>Collection有3个子接口：List（顺序表）、Set（堆）、Queue（队列）</p>
<h2 id="list">List</h2>
<p>List常见的实现类是ArrayList、Vector和Stack（栈）<br>
ArrayList是非线程安全的，在多线程下需要手动保证集合的同步性；而Vector是线程安全的<br>
但是因为性能较差和有其他诸多缺点，在实际使用中仍然不推荐使用Vector。建议使用ArrayList并搭配Collections工具类保证线程安全</p>
<h2 id="set">Set</h2>
<p>Set常见的实现类是HashSet，还有TreeSet和EnumSet（专为枚举类设计）<br>
HashSet的存储类似使用链地址法解决冲突的哈希表</p>
<h2 id="迭代器iterator">迭代器：Iterator</h2>
<p>Iterator接口是Collection的父接口，因此可以使用Collection.iterator()获取到Iterator，然后访问、操作数据</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
Iterator&lt;String&gt; iterator = list.iterator();
while(iterator.hasNext()){
    System.out.println(iterator.next())
}
</code></pre>
<h2 id="集合工具类">集合工具类</h2>
<p>Java还提供了两个较为实用的辅助工具类Collections和Arrays</p>
<h1 id="map接口键值对">Map接口（键值对）</h1>
<p>Map常见的实现类有HashMap和TreeMap</p>
<pre><code>HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;&gt;();
hashMap.put(1,&quot;aa&quot;);
System.out.println(hashMap.get(1))
</code></pre>
<h1 id="集合转换">集合转换</h1>
<p>将Map集合转换为Collection集合有3种方法：entrySet()、keySet()和values()，这三种方法分别返回键值对集合、键的集合和值的集合</p>
<pre><code>HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;&gt;();

//使用entrySet获取Entry键值对集合
Set&lt;Entry&lt;Integer,String&gt;&gt; set = hashMap.entrySet();
for(Entry&lt;Integer,String&gt; entry: set){
    System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());
}

//使用keySet获取键集合（使用values获取值集合类似）
Set&lt;Integer&gt; set = hashMap.keyySet();
for(Integer key: keySet){
    System.out.println(key);
}
</code></pre>
]]></content>
    </entry>
</feed>